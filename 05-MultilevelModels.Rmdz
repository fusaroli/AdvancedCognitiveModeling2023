---
title: "05-MultilevelModeling"
output: html_document
date: "2023-02-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
pacman::p_load(tidyverse,
               here,
               posterior,
               cmdstanr,
               brms, tidybayes)
agents <- 100
trials <- 120
noise <- .2
rateM <- 0.8
rateSD <- 0.1
alphaM <- 0
alphaSD <- 0.1
betaM <- 1.5
betaSD <- 0.3

RandomAgentNoise_f <- function(rate, noise) {
  choice <- rbinom(1, 1, rate)
  if (rbinom(1, 1, noise) == 1) {
    choice = rbinom(1, 1, 0.5)
  }
  return(choice)
}

MemoryAgentNoise_f <- function(alpha, beta, otherRate, noise) {
  rate <- inv_logit_scaled(alpha + beta * otherRate)
  choice <- rbinom(1, 1, rate)
  if (rbinom(1, 1, noise) == 1) {
    choice = rbinom(1, 1, 0.5)
  }
  return(choice)
}

d <- NULL

for (agent in 1:agents) {
  
  rate <- rnorm(1, rateM, rateSD)
  alpha <- rnorm(1, alphaM, alphaSD)
  beta <- rnorm(1, betaM, betaSD)
  
  if (rate > 1) {rate = 1}
  
  randomChoice <- rep(NA, trials)
  memoryChoice <- rep(NA, trials)
  memoryRate <- rep(NA, trials)
  
  for (trial in 1:trials) {
    
    randomChoice[trial] <- RandomAgentNoise_f(rate, noise)
    if (trial == 1) {
      memoryChoice[trial] <- rbinom(1,1,0.5)
      memoryRate[trial] <- NA
    } else {
      memoryChoice[trial] <- MemoryAgentNoise_f(alpha, beta, mean(randomChoice, na.rm = T), noise)
      memoryRate[trial] <- mean(randomChoice, na.rm = T)
    }
  }
  
  tempRandom <- tibble(agent, trial = seq(trials), choice = randomChoice, rate, noise, rateM, rateSD, alpha, beta, alphaM, alphaSD, betaM, betaSD, strategy = "Random")
  tempMemory <- tibble(agent, trial = seq(trials), choice = memoryChoice, rate = memoryRate, noise, rateM, rateSD, alpha, beta, alphaM, alphaSD, betaM, betaSD, strategy = "Memory")
  
  temp <- rbind(tempRandom, tempMemory)
  
  if (agent > 1) {
    d <- rbind(d, temp)
  } else{
    d <- temp
  }
  
}

d <- d %>% group_by(agent, strategy) %>% mutate(
  cumulativerate = cumsum(choice) / seq_along(choice)
)

p1 <- ggplot(d, aes(trial, cumulativerate, group = agent, color = agent)) + 
  geom_line() + 
  geom_hline(yintercept = 0.5, linetype = "dashed") + ylim(0,1) + theme_classic() + facet_wrap(.~strategy)
p1

d1 <- d %>% subset(strategy == "Random") %>% subset(select = c(agent, choice)) %>% mutate(row = row_number()) %>% pivot_wider(names_from = agent, values_from = choice)

## Create the data
data <- list(
  trials = trials,
  agents = agents,
  h = as.matrix(d1[,2:101])
)
file <- file.path("/Users/au209589/Dropbox (Personal)/My courses/2022 - AdvancedCognitiveModeling/W6_Stan_v2.stan")
mod <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE))

# The following command calls Stan with specific options.
samples <- mod$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 2000,
  iter_sampling = 2000,
  refresh = 500,
  max_treedepth = 20,
  adapt_delta = 0.99,
)

samples$cmdstan_diagnose()
samples$summary() 

draws_df <- as_draws_df(samples$draws()) 

ggplot(draws_df, aes(.iteration, thetaM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, thetaSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df) +
  geom_histogram(aes(prior_preds), color = "darkblue", fill = "blue", alpha = 0.3) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(thetaM)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(thetaM_prior)), fill = "red", alpha = 0.3) +
  xlab("Mean Rate") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_density(aes(thetaSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(thetaSD_prior), fill = "red", alpha = 0.3) +
  xlab("Variance of Rate") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_density(aes(theta_posterior), fill = "blue", alpha = 0.3) +
  geom_density(aes(theta_prior), fill = "red", alpha = 0.3) +
  xlab("Broader Rate") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(`theta[1]`)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[15]`)), fill = "green", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[21]`)), fill = "lightblue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[31]`)), fill = "darkblue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[41]`)), fill = "yellow", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[51]`)), fill = "darkgreen", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[61]`)), fill = "lightgreen", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(thetaM_prior)), fill = "pink", alpha = 0.3) +
  geom_density(aes(theta_prior), fill = "purple", alpha = 0.3) +
  xlab("Mean Rate") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_histogram(aes(prior_preds), color = "darkblue", fill = "lightblue", alpha = 0.3) +
  geom_histogram(aes(posterior_preds), color = "darkblue", fill = "blue", alpha = 0.3) +
  geom_histogram(data = d %>% group_by(agent) %>% dplyr::summarise(heads = sum(choice)), aes(heads), fill = "green", color = "darkgreen", alpha = 0.8) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

draws_df <- draws_df %>% mutate(
  preds1 = rbinom(2000,120, inv_logit_scaled(`theta[1]`)),
  preds11 = rbinom(2000,120, inv_logit_scaled(`theta[11]`)),
  preds21 = rbinom(2000,120, inv_logit_scaled(`theta[21]`)),
  preds31 = rbinom(2000,120, inv_logit_scaled(`theta[31]`)),
  preds41 = rbinom(2000,120, inv_logit_scaled(`theta[41]`)),
  preds51 = rbinom(2000,120, inv_logit_scaled(`theta[51]`)),
  preds61 = rbinom(2000,120, inv_logit_scaled(`theta[61]`)),
  preds71 = rbinom(2000,120, inv_logit_scaled(`theta[71]`)),
  preds81 = rbinom(2000,120, inv_logit_scaled(`theta[81]`)),
  preds91 = rbinom(2000,120, inv_logit_scaled(`theta[91]`)),
)

d2 <- d %>% group_by(agent) %>% dplyr::summarise(heads = sum(choice))

ggplot(draws_df) +
  geom_density(aes(posterior_preds), color = "skyblue1", alpha = 0.3) +
  geom_density(data = d2, aes(heads),  color = "darkblue",alpha = 0.8) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

p1 <- ggplot(draws_df) +
  geom_density(aes(preds1), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 1)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()

p2 <- ggplot(draws_df) +
  geom_density(aes(preds11), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 11)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()
  
p3 <- ggplot(draws_df) +
  geom_density(aes(preds21), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 21)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()

library(patchwork)
p1 + p2 + p3

## Create the data
d1 <- d %>% subset(strategy == "Memory") %>% 
  subset(select = c(agent, choice)) %>% 
  mutate(row = row_number()) %>% 
  pivot_wider(names_from = agent, values_from = choice)
d2 <- d %>% subset(strategy == "Memory") %>% 
  subset(select = c(agent, rate)) %>% 
  mutate(row = row_number()) %>% 
  pivot_wider(names_from = agent, values_from = rate)


data <- list(
  trials = trials - 1,
  agents = agents,
  h = as.matrix(d1[2:120,2:101]),
  memory = as.matrix(d2[2:120,2:101])
)

file <- file.path("/Users/au209589/Dropbox (Personal)/My courses/2022 - AdvancedCognitiveModeling/W6_Stan_GLM_v2a.stan")
mod1 <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE))

# The following command calls Stan with specific options.
samples1 <- mod1$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 2000,
  iter_sampling = 2000,
  refresh = 500,
  max_treedepth = 20,
  adapt_delta = 0.99,
)

samples$cmdstan_diagnose()
samples$summary(c("alphaM", "betaM", "alphaSD", "betaSD"))

draws_df <- as_draws_df(samples$draws()) 

p1 <- ggplot(draws_df, aes(.iteration, alphaM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

p2 <- ggplot(draws_df, aes(.iteration, alphaSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

p3 <- ggplot(draws_df, aes(.iteration, betaM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

p4 <- ggplot(draws_df, aes(.iteration, betaSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

p1 + p2 + p3 + p4

p1 <- ggplot(draws_df, aes(alphaM, log(alphaSD), group = .chain, color = .chain)) +
  geom_point(alpha = 0.1) +
  theme_classic()
p2 <- ggplot(draws_df, aes(alphaM, betaM, group = .chain, color = .chain)) +
  geom_point(alpha = 0.1) +
  theme_classic()

p1 + p2
##
ggplot(draws_df) +
  geom_histogram(aes(`prior_preds[1,1]`), color = "darkblue", fill = "blue", alpha = 0.3) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

p1 <- ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(alphaM)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(alphaM_prior)), fill = "red", alpha = 0.3) +
  xlab("Mean Rate") +
  ylab("Posterior Density") +
  theme_classic()

p2 <- ggplot(draws_df) +
  geom_density(aes(alphaSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(alphaSD_prior), fill = "red", alpha = 0.3) +
  xlab("Variance of Rate") +
  ylab("Posterior Density") +
  theme_classic()

p3 <- ggplot(draws_df) +
  geom_density(aes(betaM), fill = "blue", alpha = 0.3) +
  geom_density(aes(betaM_prior), fill = "red", alpha = 0.3) +
  xlab("Mean Rate") +
  ylab("Posterior Density") +
  theme_classic()

p4 <- ggplot(draws_df) +
  geom_density(aes(betaSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(betaSD_prior), fill = "red", alpha = 0.3) +
  xlab("Variance of Rate") +
  ylab("Posterior Density") +
  theme_classic()

p1 + p2 + p3 + p4 

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(`theta[1]`)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[15]`)), fill = "green", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[21]`)), fill = "lightblue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[31]`)), fill = "darkblue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[41]`)), fill = "yellow", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[51]`)), fill = "darkgreen", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(`theta[61]`)), fill = "lightgreen", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(thetaM_prior)), fill = "pink", alpha = 0.3) +
  geom_density(aes(theta_prior), fill = "purple", alpha = 0.3) +
  xlab("Mean Rate") +
  ylab("Posterior Density") +
  theme_classic()

ggplot(draws_df) +
  geom_histogram(aes(prior_preds), color = "darkblue", fill = "lightblue", alpha = 0.3) +
  geom_histogram(aes(posterior_preds), color = "darkblue", fill = "blue", alpha = 0.3) +
  geom_histogram(data = d %>% group_by(agent) %>% dplyr::summarise(heads = sum(choice)), aes(heads), fill = "green", color = "darkgreen",alpha = 0.8) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

draws_df <- draws_df %>% mutate(
  preds1 = rbinom(2000,120, inv_logit_scaled(`theta[1]`)),
  preds11 = rbinom(2000,120, inv_logit_scaled(`theta[11]`)),
  preds21 = rbinom(2000,120, inv_logit_scaled(`theta[21]`)),
  preds31 = rbinom(2000,120, inv_logit_scaled(`theta[31]`)),
  preds41 = rbinom(2000,120, inv_logit_scaled(`theta[41]`)),
  preds51 = rbinom(2000,120, inv_logit_scaled(`theta[51]`)),
  preds61 = rbinom(2000,120, inv_logit_scaled(`theta[61]`)),
  preds71 = rbinom(2000,120, inv_logit_scaled(`theta[71]`)),
  preds81 = rbinom(2000,120, inv_logit_scaled(`theta[81]`)),
  preds91 = rbinom(2000,120, inv_logit_scaled(`theta[91]`)),
)

d2 <- d %>% group_by(agent) %>% dplyr::summarise(heads = sum(choice))

ggplot(draws_df) +
  geom_density(aes(posterior_preds), color = "skyblue1", alpha = 0.3) +
  geom_density(data = d2, aes(heads),  color = "darkblue",alpha = 0.8) +
  xlab("Predicted heads out of 120 trials") +
  ylab("Posterior Density") +
  theme_classic()

p1 <- ggplot(draws_df) +
  geom_density(aes(preds1), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 1)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()

p2 <- ggplot(draws_df) +
  geom_density(aes(preds11), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 11)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()

p3 <- ggplot(draws_df) +
  geom_density(aes(preds21), color = "skyblue1", alpha = 0.3) +
  geom_point(x = subset(d2, agent == 21)$heads, y = 0, shape = 23, color = "darkblue", fill = "darkblue") +
  theme_classic()

library(patchwork)
p1 + p2 + p3


diagnostics_df <- as_draws_df(samples$sampler_diagnostics())
print(diagnostics_df)

draws_df$divergence = diagnostics_df$divergent__
div <- draws_df[draws_df$divergence == 1,]


p1 <- ggplot(draws_df) +
  geom_point(aes(`alphaM`, log(alphaSD)), alpha = 0.1) +
  geom_point(data = div, aes(`alphaM`, log(alphaSD)), color = "red") +
  theme_classic()

p2 <- ggplot(draws_df) +
  geom_point(aes(`alphaM`, betaM), alpha = 0.1) +
  geom_point(data = div, aes(`alphaM`, betaM), color = "red") +
  theme_classic()

p3 <- ggplot(draws_df) +
  geom_point(aes(`betaM`, log(betaSD)), alpha = 0.1) +
  geom_point(data = div, aes(`betaM`, log(betaSD)), color = "red") +
  theme_classic()

p1 + p2 + p3



d4 <- d3 %>% mutate(Rate0 = alpha, Rate1 = alpha + beta) %>% 
  pivot_longer(c(Rate0, Rate1), names_to = "Condition", values_to = "Rate") %>% 
  mutate(Condition = parse_number(Condition)) %>%
  group_by(agent, Condition) %>% dplyr::summarize(Rate = mean(Rate))


ggplot(d4, aes(Condition,Rate, color = agent, group = agent)) + theme_bw() + geom_point() + geom_smooth(method = lm, se = F)

RanEf <- samples %>%
  spread_draws(alphaID[agent], betaID[agent]) %>% 
  mutate(Rate0 = alphaID + alphaM, Rate1 = alphaID + alphaM + (betaM + betaID)) %>% 
  pivot_longer(c(Rate0, Rate1), names_to = "Condition", values_to = "Rate") %>% 
  mutate(Condition = parse_number(Condition)) %>%
  group_by(agent, Condition) %>% dplyr::summarize(Rate = mean(Rate))

ggplot(RanEf, aes(Condition,Rate, color = agent, group = agent)) + theme_bw() + geom_smooth(method = lm, se = F)

ggplot() +
  theme_bw() +
  geom_smooth(data = d4, aes(Condition, Rate), method = lm, se = F) +
  geom_smooth(data = RanEf, aes(Condition, Rate), method = lm, se = T, color = "red")

draws_df$alphaM_true <- d3$alphaM[1]
draws_df$betaM_true <- d3$betaM[1]

ggplot(draws_df) +
  geom_point(aes(alphaM, betaM), alpha = 0.1) +
  geom_point(aes(alphaM_true, betaM_true), alpha = 0.1, color = "red") +
  theme_bw()


### BRMS
d3 <- d %>% subset(strategy == "Memory")
prior <- c(
  prior(normal(0,.1), class = Intercept), 
  prior(normal(0,1), class = b), 
  prior(normal(0,.3), class = sd),
  prior(lkj(3), class = cor))
m <- brm(choice ~ 1 + rate + (1 + rate | agent), d3, family = bernoulli(), chains = 1, prior = prior)

stancode(m)


data <- list(
  trials = trials - 1,
  agents = agents,
  h = as.matrix(d1[2:120,2:101]),
  memory = as.matrix(d2[2:120,2:101])
)

file <- file.path("/Users/au209589/Dropbox (Personal)/My courses/2022 - AdvancedCognitiveModeling/W6_Stan_GLM_v2b.stan")
mod2 <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE))

# The following command calls Stan with specific options.
samples2 <- mod2$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 2000,
  iter_sampling = 2000,
  refresh = 500,
  max_treedepth = 20,
  adapt_delta = 0.99,
)

file <- file.path("/Users/au209589/Dropbox (Personal)/My courses/2022 - AdvancedCognitiveModeling/W6_Stan_v2_noPooling.stan")
mod <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE))
samples <- mod$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 2000,
  iter_sampling = 2000,
  refresh = 500,
  max_treedepth = 20,
  adapt_delta = 0.99,
)

samples$loo()

```

## BONUS CONTENT - Including noise in the generative model

N.B. This should all be parallelized.

### First with brms as a sanity check

```{r message = FALSE}
## Mixture in brms
dd <- d %>% subset(rate == 0.8 & noise == 0.1)

formula <- bf(choice ~ 1)

mix <- mixture(bernoulli, bernoulli)

get_prior(formula, family = mix, dd)

prior <- c(
  prior(normal(0, .1), class = "Intercept", dpar = mu1),
  prior(normal(0, 1), class = "Intercept", dpar = mu2)
)

m <- brm(formula, 
         family = mix, 
         prior = prior, 
         data = dd,
         backend = "cmdstanr", 
         chains = 2, 
         cores = 2, 
         control = list(adapt_delta = 0.99),
         stan_model_args = list(stanc_options = list("O1")))

## Now we need to scale it up to all possible rates and noises
recovery_df <- NULL

for (noiseLvl in unique(d$noise)) {
  
  for (rateLvl in unique(d$rate)) {
    
    dd <- d %>% subset(
      noise == noiseLvl  & rate == rateLvl
    )
    m <- brm(
        formula,
        family = mix,
        prior = prior,
        data = dd,
        backend = "cmdstanr",
        chains = 2,
        cores = 2,
        control = list(adapt_delta = 0.99),
        refresh = 1000,
        stan_model_args = list(stanc_options = list("O1")))
    
    post_preds <- spread_draws(m, b_mu2_Intercept, theta1)
    
    temp <- tibble(biasEst = post_preds$b_mu2_Intercept, 
                   biasTrue = rateLvl, 
                   noiseEst = post_preds$theta1, 
                   noiseTrue = noiseLvl, 
                   Randomness = post_preds$b_mu2_Intercept,
                   Bias_p = post_preds$theta2)
    
    if (exists("recovery_df")) {
      recovery_df <- rbind(recovery_df, temp)
      } else {recovery_df <- temp}
    
  }}

ggplot(recovery_df, aes(biasTrue, biasEst)) +
  geom_point(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(.~noiseTrue) +
  theme_classic()

```

### Then coding it directly in Stan

```{r message = FALSE}
dd <- d %>% subset(rate == 0.8 & noise == 0.1)
data <- list(
  n = 120,
  h = dd$choice
)
file <- file.path("stan/W3_mixture.stan")
mod <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1"))
samples <- mod$sample(
  data = data,
  seed = 123,
  chains = 2,
  parallel_chains = 2,
  threads_per_chain = 2,
  iter_warmup = 1500,
  iter_sampling = 3000,
  refresh = 500,
  max_treedepth = 20,
  adapt_delta = 0.99,
)

## Now we need to scale it up to all possible rates and noises
recovery_Standf <- NULL

for (noiseLvl in unique(d$noise)) {
  
  for (rateLvl in unique(d$rate)) {
    
    dd <- d %>% subset(
      noise == noiseLvl  & rate == rateLvl
    )
    
    data <- list(
      n = nrow(dd),
      h = dd$choice
    )
    
    samples <- mod$sample(
      data = data,
      seed = 123,
      chains = 1,
      parallel_chains = 1,
      threads_per_chain = 1,
      iter_warmup = 2000,
      iter_sampling = 4000,
      refresh = 1000,
      max_treedepth = 20,
      adapt_delta = 0.99,
    )
    
    draws_df <- as_draws_df(samples$draws()) 
    temp <- tibble(biasEst = draws_df$bias_p, 
                   biasTrue = rateLvl, 
                   noiseEst = draws_df$noise_p, 
                   noiseTrue = noiseLvl)
    
    
    if (exists("recovery_Standf")) {
      recovery_Standf <- rbind(recovery_Standf, temp)
      } else {recovery_Standf <- temp}
    
  }
  
}


ggplot(recovery_Standf, aes(biasTrue, biasEst)) +
  geom_point(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(.~noiseTrue) +
  ylim(0,1) +
  theme_classic()

ggplot(recovery_Standf, aes(noiseTrue, noiseEst)) +
  geom_point(alpha = 0.1) +
  geom_smooth() +
  facet_wrap(.~biasTrue) +
  ylim(0,1) +
  theme_classic()
```

### Now we add different priors for noise

```{r message = FALSE}
## Now we adding different priors for noise
NoiseMean <- seq(-3,0, .5)
NoiseStD <- seq(0.1, 1, 0.1)
noisePriors <-  expand.grid(NoiseMean = NoiseMean, NoiseStD = NoiseStD)

file <- file.path("stan/W3_mixture_v2.stan")
mod <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1"))


recovery_Standf3 <- NULL

for (p in seq(nrow(noisePriors))) {

for (noiseLvl in unique(d$noise)) {
  
  for (rateLvl in unique(d$rate)) {
    
    dd <- d %>% subset(
      noise == noiseLvl  & rate == rateLvl
    )
    
    data <- list(
      n = nrow(dd),
      h = dd$choice,
      noiseM = noisePriors$NoiseMean[p],
      noiseSd = noisePriors$NoiseStD[p]
    )
    
    samples <- mod$sample(
      data = data,
      seed = 123,
      chains = 1,
      parallel_chains = 1,
      threads_per_chain = 1,
      iter_warmup = 2000,
      iter_sampling = 4000,
      refresh = 1000,
      max_treedepth = 20,
      adapt_delta = 0.99,
    )
    
    draws_df <- as_draws_df(samples$draws()) 
    temp <- tibble(biasEst = draws_df$bias_p, 
                   biasTrue = rateLvl, 
                   noiseEst = draws_df$noise_p, 
                   noiseTrue = noiseLvl,
                   noiseM = noisePriors$NoiseMean[p],
                   noiseSd = noisePriors$NoiseStD[p])
    
    
    if (exists("recovery_Standf3")) {
      recovery_Standf3 <- rbind(recovery_Standf3, temp)
    } else {
        recovery_Standf3 <- temp}
    
  }
  
}
}
```

### Now also playing with priors for theta

```{r message = FALSE}
## Now we adding different priors for theta
prior_mean <- seq(-3, 3, .5)
prior_sd <- seq(0.1, 1, 0.1)
priors <-  expand.grid(prior_mean, prior_sd)
priors <- tibble(prior_mean = priors$Var1, prior_sd = priors$Var2)

file <- file.path("stan/W3_mixture_v3.stan")
mod <- cmdstan_model(file, cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1"))

dd <- d %>% subset(noise == 0.1 & rate == 0.8)

sensitivity_df <- NULL

for (p in seq(nrow(priors))) {
  
      data <- list(
        n = nrow(dd),
        h = dd$choice,
        prior_mean = priors$prior_mean[p],
        prior_sd = priors$prior_sd[p]
      )
      
      samples <- mod$sample(
        data = data,
        seed = 123,
        chains = 1,
        parallel_chains = 1,
        threads_per_chain = 1,
        iter_warmup = 1000,
        iter_sampling = 1000,
        refresh = 1000,
        max_treedepth = 20,
        adapt_delta = 0.99,
      )
      
      draws_df <- as_draws_df(samples$draws()) 
      temp <- tibble(theta_prior = draws_df$theta_prior, 
                     theta_posterior = draws_df$theta_posterior, 
                     prior_preds = draws_df$prior_preds, 
                     posterior_preds = draws_df$posterior_preds, 
                     prior_mean = priors$prior_mean[p],
                     prior_sd = priors$prior_sd[p])
      
      
      if (exists("sensitivity_df")) {
        sensitivity_df <- rbind(sensitivity_df, temp)
      } else {
          sensitivity_df <- temp}
      
}

ggplot(sensitivity_df, aes(prior_mean, theta_posterior)) +
  geom_point(alpha = 0.01) +
  geom_hline(yintercept = 0.8, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "blue") +
  facet_wrap(.~prior_sd) +
  theme_bw()

ggplot(sensitivity_df, aes(prior_sd, theta_posterior)) +
  geom_point(alpha = 0.01) +
  geom_hline(yintercept = 0.8, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "blue") +
  facet_wrap(.~prior_mean) +
  theme_bw()

ggplot(sensitivity_df, aes(prior_mean, posterior_preds)) +
  geom_point(alpha = 0.01) +
  geom_hline(yintercept = 96, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "blue") +
  facet_wrap(.~prior_sd) +
  theme_bw()

ggplot(sensitivity_df, aes(prior_sd, posterior_preds)) +
  geom_point(alpha = 0.01) +
  geom_hline(yintercept = 96, linetype = "dashed", color = "red") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "blue") +
  facet_wrap(.~prior_mean) +
  theme_bw()
```
