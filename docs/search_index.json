[["index.html", "09-BayesianModels Chapter 1 Advanced Cognitive Modeling 1.1 The goal of the course 1.2 List of lectures and practical exercises 1.3 Preparation before the course", " 09-BayesianModels Riccardo Fusaroli 2023-03-18 Chapter 1 Advanced Cognitive Modeling These are the teaching notes for Advanced Cognitive Modeling - taught in 2023 at the M.Sc. in Cognitive Science at Aarhus University. The syllabus is available at https://docs.google.com/document/d/1D8NTG0o4nD86AUdyyTp1hZIybg4ZEt9kdJ6mvfa_IQo/edit?usp=sharing The videos are available at https://youtube.com/playlist?list=PL_f3yDs5oZx6bfywYiGitMJPdJv6gZfXu 1.1 The goal of the course Advanced cognitive modeling is a course on how to think through, formalize and validate models of cognitive processes. In other words, we will be thinking about how people learn, and make decisions both in the lab and in the real world, and to robustly assess our hypothesized mechanisms. The course has 3 interrelated aims: to guide you through how models of cognitive processes are thought through and built (more than a toolbox of existing scripts); to provide (or reinforce) a good Bayesian workflow (simulation, prior assessment, parameter/model recovery, model fit assessment) to build robust and reliable models; to develop your probabilistic modeling skills (we will be dealing with brms, and also directly with stan). At the end of the course, you should be able to start thinking about how to use your own theoretical knowledge in cognitive science to build your own models, as well as to robustly evaluate existing models and their applicability. The course will be very hands-on. The main goal of the course is not just for you to understand how cognitive modeling works, but to build and use your own models. The lectures will include conceptual discussions of cognitive modeling and the specific models we will be dealing with, but also introduction to the coding exercises in the practical exercises (e.g. how to code in Stan). During the practical exercises, we will collect some data or explore existing datasets, design models together, and code them up: simulating how a person using those processes would perform, inferring parameters from simulated and real data, assessing model quality. We will take the time to do this together, and there will be time for lots of questions. The schedule for the course will therefore be somewhat flexible, and adaptive to your collective learning speed. See the planned schedule below. 1.2 List of lectures and practical exercises 1.3 Preparation before the course Before starting the course, you need to get your computers and brains in ship-shape so we can focus on modeling! In terms of computers, you need to make sure you have the following software installed and working: * up-to-date R (version 4 or above) and Rstudio (version 1.3 or above) installed and working. See here for a more detailed instruction on how to install R and Rstudio: https://happygitwithr.com/install-r-rstudio.html * the “brms” package installed: https://github.com/paul-buerkner/brms N.B. it’s not always as simple as doing an install.packages(“brms”), so do follow the linked guide! * the “cmdstanr” package: https://mc-stan.org/cmdstanr/articles/cmdstanr.html N.B. it’s not always as simple as doing an install.packages(“cmdstanr”), so do follow the linked guide! N.B. technically you can run all our exercises without cmdstanr if it turns to be too demanding, but your computer will be much slower. Without these packages working, you will not be able to tackle the practical exercises, so install them before you move to the next section and make sure there are no errors or worrying warnings. Once your computer is ready, you should also get your brain ready. This workshop focuses on how to do Bayesian data analysis and does not go into the details of Bayes’ theorem. If you are not familiar with the theorem or need a quick refresh, we strongly recommend you give this 15 min video a watch before the workshop. This should make talk of priors and posteriors much easier to parse. https://www.youtube.com/watch?v=HZGCoVF3YvM This workshop does not cover basic R coding and basic statistical modeling, they are taken for granted. I know not everybody comes from the Bsc in Cognitive Science, so if you feel you need some practice: * An amazing intro to R and the tidyverse (free online): https://r4ds.had.co.nz/ (I know some of you have also been referred to swirl and datacamp, I don’t know those resources, so have a look at the one above to check you know enough) * A intro to Bayesian statistics in brms (summarizing key points from methods 4 in the bachelor): https://4ccoxau.github.io/PriorsWorkshop/ videos + exercises. "],["practical-exercise-1---building-verbal-models-of-the-matching-pennies-game.html", "Chapter 2 Practical exercise 1 - Building verbal models of the matching pennies game 2.1 Trying out the game and collecting your own data 2.2 Start Theorizing 2.3 The distinction between participant and researcher perspectives 2.4 Strategies 2.5 Cognitive constraints 2.6 Continuity between models 2.7 Mixture of strategies", " Chapter 2 Practical exercise 1 - Building verbal models of the matching pennies game 2.1 Trying out the game and collecting your own data Today’s practical exercise is structured as follows: In order to do computational models we need a phenomenon to study (and ideally some data), you will therefore undergo an experiment, which will provide you with two specific cognitive domains to describe (one for now, one for later), and data from yourselves. You will now have to play the Matching Pennies Game against each other. In the Matching Pennies Game you and your opponent have to choose either “left” or “right” to indicate the hand in which the penny is hidded. If you are the matcher, you win by choosing the same as your opponent. If you are the capitalist with the penny, you win by choosing the opposite as your opponent. You should run 30 rounds with one of you being the capitalist and the other the matcher and then exchange roles for 30 more rounds. When you are the matcher, keep track of your score: every time you guess right you get +1, every time you don’t you get -1. The capitalist gets exactly the opposite, so if the matcher ends with a negative score, the capitalist has won and vice versa. Given you play many trials the game can take a while. If you want to take a break or do it in two sessions, feel free! Try to pay attention and aim at winning. As you play also try to figure out what kind of strategies might be at play for you and for the opponents. How are you deciding whether to choose left or right? Feel free to take notes. 2.2 Start Theorizing The goal of today’s assignment is to build models of the strategies and cognitive processes underlying behavior in the matching pennies game. In other words, to build hypotheses as to how the data is generated. The goal is to: 1) get you more aware of the issue of theory building (and assessment); 2) identify a small set of verbal models that we can then formalize in mathematical cognitive models and algorithms for simulations and model fitting. First, let’s take a little free discussion: Did you enjoy the game? What was the game about? What do you think your opponent was doing? Below you can observe how a previous year of CogSci did against bots (computational agents) playing according to different strategies. Look at the plots below, where the x axes indicate trial, the y axes how many points the CogSci’ers scored (0 being chance, negative means being completely owned by the bots, positive owning the bot) and the different colors indicate different strategies employed by the bots. Strategy “-2” was a Win-Stay-Lose-Shift bot: when it got a +1, it repeated its previous move (e.g. right if it had just played right), otherwise it would perform the opposite move (e.g. left if it had just played right). Strategy “-1” was a biased Nash both, playing “right” 80% of the time. Strategy “0” indicates a reinforcement learning bot; “1” a bot assuming you were playing according to a reinforcement learning strategy and trying to infer your learning and temperature parameters; “2” a bot assuming you were following strategy “1” and trying to accordingly infer your parameters. library(tidyverse) d &lt;- read_csv(&quot;data/MP_MSc_CogSci22.csv&quot;) %&gt;% mutate(BotStrategy = as.factor(BotStrategy)) ## Rows: 4400 Columns: 11 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (2): ID, BotParameters ## dbl (9): BotStrategyN, Role, player.tom_role, Choice, BotChoice, Payoff, BotPayoff, Trial, BotStrategy ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. d$Role &lt;- ifelse(d$Role == 0, &quot;Matcher&quot;, &quot;Mismatcher&quot;) ggplot(d, aes(Trial, Payoff, group = BotStrategy, color = BotStrategy)) + geom_smooth(se = F) + theme_classic() + facet_wrap(.~Role) ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; That doesn’t look too good, ah? What about individual variability? In the plot below we indicate the score of each of the former students, against the different bots. d1 &lt;- d %&gt;% group_by(ID, BotStrategy) %&gt;% dplyr::summarize(Score = sum(Payoff)) ## `summarise()` has grouped output by &#39;ID&#39;. You can override using the `.groups` argument. ggplot(d1, aes(BotStrategy, Score, label = ID)) + geom_point(aes(color = ID)) + geom_boxplot(alpha = 0.3) + theme_classic() ## Warning: The following aesthetics were dropped during statistical transformation: label ## ℹ This can happen when ggplot fails to infer the correct grouping structure in the data. ## ℹ Did you forget to specify a `group` aesthetic or to convert a numerical variable into a factor? Now, let’s take a bit of group discussion. Get together in groups, and discuss which strategies and cognitive processes might underlie your and the agents’ behaviors in the game. One thing to keep in mind is what a model is: a simplification that can help us make sense of the world. In other words, any behavior is incredibly complex and involves many complex cognitive mechanisms. So start simple, and if you think it’s too simple, progressively add simple components. Once your study group has discussed a few (during the PE), add them here: https://docs.google.com/document/d/13OZL3CF9qM0744Y81BBKtvlu9k5E0F_tuuuU9DILRMU/edit?usp=sharing (shorturl.at/nrAKV) 2.3 The distinction between participant and researcher perspectives As participants we might not be aware of the strategy we use, or we might believe something erroneous. The exercise here is to act as researchers: what are the principles underlying the participants’ behaviors, no matter what the participants know or believe? Note that talking to participants and being participants help developing ideas, but it’s not the end point of the process. Also note that as cognitive scientists we can rely on what we have learned about cognitive processes (e.g. memory). 2.4 Strategies 2.4.1 Random strategies Players might simply be randomly choosing “head” or “tail” independently on the opponent’s choices and of how well they are doing. Choices could be fully at random (50% “head”, 50% “tail”) or biased (e.g. 60% “head”, 40% tail). 2.4.2 Immediate reaction Another simple strategy is simply to follow the previous choice: if it was successful keep it, if not change it. This strategy is also called Win-Stay-Lose-Shift (WSLS). Alternatively, one could do the opposite: Win-Shift-Lose-Stay. 2.4.3 Keep track of the bias (perfect memory) A player could keep track of biases in the opponent: count the proportion of “head” on the total trials so far and choose whichever choice has been made most often by the opponent. 2.4.4 Keep track of the bias (imperfect memory) A player could not be able to keep in mind all previous trials, or decide to forget old trials, in case the biase shifts over time. So we could use only the last n trials, or do a weighted mean with weigths proportional to temporal closeness (the more recent, the higher the weight). 2.4.5 Reinforcement learning Since there is a lot of leeway in how much memory we should keep of previous trials, we could also use a model that explicitly estimates how much players are learning on a trial by trial basis (high learning, low memory; low learning, high memory). This is the model of reinforcement learning, which we will deal with in future chapters. Shortly described, reinforcement learning assumes that each choice has a possible reward (probability of winning) and at every trial given the feedback received updates the expected value of the choice taken. The update depends on the prediction error (difference between expected and actual reward) and the learning rate. 2.4.6 k-ToM Reinforcement learning is a neat model, but can be problematic when playing against other agents: what the game is really about is not assessing the probability of the opponent choosing “head” generalizing from their past choices, but predicting what they will do. This requires making an explicit model of how the opponent chooses. k-ToM models will be dealt with in future chapters, but can be here anticipated as models assuming that the opponent follows a random bias (0-ToM), or models us as following a random bias (1-ToM), or models us modeling them as following a random bias (2-ToM), etc. 2.4.7 Other possible strategies Many additional strategies can be generated by combining former strategies. Generating random output is hard, so if we want to confuse the opponent, we could act first choosing tail 8 times, and then switching to a WSLS strategy for 4 trials, and then choosing head 4 times. Or implementing any of the previous strategies and doing the opposite “to mess with the opponent”. 2.5 Cognitive constraints As we discuss strategies, we can also identify several cognitive constraints that we know from former studies: in particular, memory and errors. 2.5.1 Memory Humans have limited memory and a tendency to forget that is roughly exponential. Models assuming perfect memory for longer stretches of trials are unrealistic. We could for instance use the exponential decay of memory to create weights following the same curve in the “keeping track of bias” models. Roughly, this is what reinforcement learning is doing via the learning rate parameter. 2.5.2 Errors Humans make mistakes, get distracted, push the wrong button, forget to check whether they won or lost before. So a realistic model of what happens in these games should contain a certain chance of making a mistake. E.g. a 10% chance that any choice will be perfectly random instead of following the strategy. Such random deviations from the strategy might also be conceptualized as explorations: keeping the door open to the strategy not being optimal and therefore testing other choices. For instance, one could have an imperfect WSLS where the probability of staying if winning (or shifting if losing) is only 80% and not 100%. Further, these deviations could be asymmetric, with the probability of staying if winning is 80% and of shifting if losing is 100%; for instance if negative and positive feedback are perceived asymmetrically. 2.6 Continuity between models Many of these models are simply extreme cases of others. For instance, WSLS is a reinforcement learning model with an extreme learning rate (reward replaces the formerly expected value without any moderation), which is also a memory model with a memory of 1 previous trial. 2.7 Mixture of strategies We discussed that there are techniques to consider the data generated by a mixture of models: estimating the probability that they are generated by model 1 or 2 or n. This probability can then be conditioned, according to our research question, to group (are people w schizophrenia more likely to employ model 1) or ID (are different participants using different models), or condition, or… We discussed that we often need lots of data to disambiguate between models, so conditioning e.g. on trial would in practice almost (?) never work. [MISSING: DISCUSSION OF DIFFERENCE BTW TRADITIONAL STAT APPROACH AND COGNITIVE MODELING; INCLUDING HOW WE DO USE THE GLM IN COGNITIVE MODELING] "],["practical-exercise-2---from-verbal-to-formal-models.html", "Chapter 3 Practical exercise 2 - From verbal to formal models 3.1 Defining general conditions 3.2 Implementing a random agent 3.3 Implementing a Win-Stay-Lose-Shift agent 3.4 Now we scale it up", " Chapter 3 Practical exercise 2 - From verbal to formal models The aim of this practical exercise is to go from verbal to formal models. We will not just write a formula, we will implement these models as algorithms in R. By implementing the models of algorithms, we are forced to make them very explicit in their assumptions; we become able to simulate the models in a variety of different situations and therefore better understand their implications So, the steps for today’s exercise are: choose two of the models and formalize them, that is, produce an algorithm that enacts the strategy, so we can simulate them. implement the algorithms as functions: getting an input and producing an output, so we can more easily implement them across various contexts (e.g. varying amount of trials, input, etc). See R4DataScience, if you need a refresher: https://r4ds.had.co.nz/functions.html implement a Random Bias agent (choosing “head” 70% of the times) and get your agents to play against it for 120 trials (and save the data) implement a Win-Stay-Lose-Shift agent (keeping the same choice if it won, changing it if it lost) and do the same. Now scale up the simulation: have 100 agents for each of your strategy playing against both Random Bias and Win-Stay-Lose-Shift and save their data. Figure out a good way to visualize the data to assess which strategy performs better, whether that changes over time and generally explore what the agents are doing. 3.1 Defining general conditions pacman::p_load(tidyverse, patchwork) trials &lt;- 120 agents &lt;- 100 3.2 Implementing a random agent Remember a random agent is an agent that picks at random between “right” and “left” independently on what the opponent is doing. A random agent might be perfectly random (50% chance of choosing “right”, same for “left”) or biased. The variable “rate” determines the rate of choosing “right”. rate &lt;- 0.5 RandomAgent &lt;- rbinom(trials, 1, rate) # we simply sample randomly from a binomial # Now let&#39;s plot how it&#39;s choosing d1 &lt;- tibble(trial = seq(trials), choice = RandomAgent) p1 &lt;- ggplot(d1, aes(trial, choice)) + geom_line() + theme_classic() p1 # What if we were to compare it to an agent being biased? rate &lt;- 0.8 RandomAgent &lt;- rbinom(trials, 1, rate) # we simply sample randomly from a binomial # Now let&#39;s plot how it&#39;s choosing d2 &lt;- tibble(trial = seq(trials), choice = RandomAgent) p2 &lt;- ggplot(d2, aes(trial, choice)) + geom_line() + theme_classic() p1 + p2 # Tricky to see, let&#39;s try writing the cumulative rate: d1$cumulativerate &lt;- cumsum(d1$choice) / seq_along(d1$choice) d2$cumulativerate &lt;- cumsum(d2$choice) / seq_along(d2$choice) p3 &lt;- ggplot(d1, aes(trial, cumulativerate)) + geom_line() + ylim(0,1) + theme_classic() p4 &lt;- ggplot(d2, aes(trial, cumulativerate)) + geom_line() + ylim(0,1) + theme_classic() p3 + p4 ## Now in the same plot d1$rate &lt;- 0.5 d2$rate &lt;- 0.8 d &lt;- rbind(d1,d2) p5 &lt;- ggplot(d, aes(trial, cumulativerate, color = rate, group = rate)) + geom_line() + ylim(0,1) + theme_classic() p5 # now as a function RandomAgent_f &lt;- function(input, rate){ n &lt;- length(input) choice &lt;- rbinom(n, 1, rate) return(choice) } input &lt;- rep(1,trials) # it doesn&#39;t matter, it&#39;s not taken into account choice &lt;- RandomAgent_f(input, rate) d3 &lt;- tibble(trial = seq(trials), choice) ggplot(d3, aes(trial, choice)) + geom_line() + theme_classic() ## What if there&#39;s noise? RandomAgentNoise_f &lt;- function(input, rate, noise){ n &lt;- length(input) choice &lt;- rbinom(n, 1, rate) if (rbinom(1, 1, noise) == 1) {choice = rbinom(1,1,0.5)} return(choice) } 3.3 Implementing a Win-Stay-Lose-Shift agent # as a function WSLSAgent_f &lt;- function(prevChoice, Feedback){ if (Feedback == 1) { choice = prevChoice } else if (Feedback == 0) { choice = 1 - prevChoice } return(choice) } WSLSAgentNoise_f &lt;- function(prevChoice, Feedback, noise){ if (Feedback == 1) { choice = prevChoice } else if (Feedback == 0) { choice = 1 - prevChoice } if (rbinom(1, 1, noise) == 1) {choice &lt;- rbinom(1, 1, .5)} return(choice) } WSLSAgent &lt;- WSLSAgent_f(1, 0) # Against a random agent Self &lt;- rep(NA, trials) Other &lt;- rep(NA, trials) Self[1] &lt;- RandomAgent_f(1, 0.5) Other &lt;- RandomAgent_f(seq(trials), rate) for (i in 2:trials) { if (Self[i - 1] == Other[i - 1]) { Feedback = 1 } else {Feedback = 0} Self[i] &lt;- WSLSAgent_f(Self[i - 1], Feedback) } sum(Self == Other) ## [1] 85 df &lt;- tibble(Self, Other, trial = seq(trials), Feedback = as.numeric(Self == Other)) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, Self)) + geom_line(color = &quot;blue&quot;, aes(trial, Other)) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, Feedback)) + geom_line(color = &quot;blue&quot;, aes(trial, 1 - Feedback)) df$cumulativerateSelf &lt;- cumsum(df$Feedback) / seq_along(df$Feedback) df$cumulativerateOther &lt;- cumsum(1 - df$Feedback) / seq_along(df$Feedback) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, cumulativerateSelf)) + geom_line(color = &quot;blue&quot;, aes(trial, cumulativerateOther)) # Against a Win-Stay-Lose Shift Self &lt;- rep(NA, trials) Other &lt;- rep(NA, trials) Self[1] &lt;- RandomAgent_f(1, 0.5) Other[1] &lt;- RandomAgent_f(1, 0.5) for (i in 2:trials) { if (Self[i - 1] == Other[i - 1]) { Feedback = 1 } else {Feedback = 0} Self[i] &lt;- WSLSAgent_f(Self[i - 1], Feedback) Other[i] &lt;- WSLSAgent_f(Other[i - 1], 1 - Feedback) } sum(Self == Other) ## [1] 60 df &lt;- tibble(Self, Other, trial = seq(trials), Feedback = as.numeric(Self == Other)) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, Self)) + geom_line(color = &quot;blue&quot;, aes(trial, Other)) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, Feedback)) + geom_line(color = &quot;blue&quot;, aes(trial, 1 - Feedback)) df$cumulativerateSelf &lt;- cumsum(df$Feedback) / seq_along(df$Feedback) df$cumulativerateOther &lt;- cumsum(1 - df$Feedback) / seq_along(df$Feedback) ggplot(df) + theme_classic() + geom_line(color = &quot;red&quot;, aes(trial, cumulativerateSelf)) + geom_line(color = &quot;blue&quot;, aes(trial, cumulativerateOther)) 3.4 Now we scale it up trials = 120 agents = 100 # WSLS vs agents with varying rates for (rate in seq(from = 0.5, to = 1, by = 0.05)) { for (agent in seq(agents)) { Self &lt;- rep(NA, trials) Other &lt;- rep(NA, trials) Self[1] &lt;- RandomAgent_f(1, 0.5) Other &lt;- RandomAgent_f(seq(trials), rate) for (i in 2:trials) { if (Self[i - 1] == Other[i - 1]) { Feedback = 1 } else {Feedback = 0} Self[i] &lt;- WSLSAgent_f(Self[i - 1], Feedback) } temp &lt;- tibble(Self, Other, trial = seq(trials), Feedback = as.numeric(Self == Other), agent, rate) if (agent == 1 &amp; rate == 0.5) {df &lt;- temp} else {df &lt;- bind_rows(df, temp)} } } ## WSLS with another WSLS for (agent in seq(agents)) { Self &lt;- rep(NA, trials) Other &lt;- rep(NA, trials) Self[1] &lt;- RandomAgent_f(1, 0.5) Other[1] &lt;- RandomAgent_f(1, 0.5) for (i in 2:trials) { if (Self[i - 1] == Other[i - 1]) { Feedback = 1 } else {Feedback = 0} Self[i] &lt;- WSLSAgent_f(Self[i - 1], Feedback) Other[i] &lt;- WSLSAgent_f(Other[i - 1], 1 - Feedback) } temp &lt;- tibble(Self, Other, trial = seq(trials), Feedback = as.numeric(Self == Other), agent, rate) if (agent == 1 ) {df1 &lt;- temp} else {df1 &lt;- bind_rows(df1, temp)} } 3.4.1 And we visualize it ggplot(df, aes(trial, Feedback, group = rate, color = rate)) + geom_smooth(se = F) + theme_classic() ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; We can see that the bigger the bias in the random agent, the bigger the performance in the WSLS (the higher the chances the random agent picks the same hand more than once in a row). Now it’s your turn to follow a similar process for your 2 chosen strategies. "],["practical-exercise-3---getting-into-stan.html", "Chapter 4 Practical exercise 3 - Getting into Stan 4.1 Overview 4.2 Simulating data 4.3 Building our basic model in Stan 4.4 Parameter recovery 4.5 The memory model: conditioning theta 4.6 Memory agent with internal parameter", " Chapter 4 Practical exercise 3 - Getting into Stan 4.1 Overview The goal of the practical exercise is to build on the simulated data from Practical Exercise 2 to construct our Stan models of the generative processes of the data. Here we know the truth: we simulated the data ourselves, so we can assess how accurate the model is in reconstructing, e.g. the bias of the agents. 4.2 Simulating data Here we build a new simulation of random agents with bias and noise. The code and visualization is really nothing different from last week’s exercise. pacman::p_load(tidyverse, here, posterior, cmdstanr, brms, tidybayes) trials &lt;- 120 RandomAgentNoise_f &lt;- function(rate, noise) { choice &lt;- rbinom(1, 1, rate) # generating noiseless choices if (rbinom(1, 1, noise) == 1) { choice = rbinom(1, 1, 0.5) # introducing noise } return(choice) } d &lt;- NULL for (noise in seq(0, 0.5, 0.1)) { # looping through noise levels for (rate in seq(0, 1, 0.1)) { # looping through rate levels randomChoice &lt;- rep(NA, trials) for (t in seq(trials)) { # looping through trials (to make it homologous to more reactive models) randomChoice[t] &lt;- RandomAgentNoise_f(rate, noise) } temp &lt;- tibble(trial = seq(trials), choice = randomChoice, rate, noise) temp$cumulativerate &lt;- cumsum(temp$choice) / seq_along(temp$choice) if (exists(&quot;d&quot;)) { d &lt;- rbind(d, temp) } else{ d &lt;- temp } } } write_csv(d, &quot;simdata/W3_randomnoise.csv&quot;) # Now we visualize it p1 &lt;- ggplot(d, aes(trial, cumulativerate, group = rate, color = rate)) + geom_line() + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + facet_wrap(.~noise) + theme_classic() p1 4.3 Building our basic model in Stan N.B. Refer to the video and slides for the step by step build-up of the Stan code. Now we subset to a simple case, no noise and rate of 0.8, to focus on the Stan model. We make it into the right format for Stan, build the Stan model, and fit it. 4.3.1 Data Here we define the data and format it for Stan. Stan likes data as a list. Why a list? Well, dataframes (now tibbles) are amazing. But they have a big drawback: they require each variable to have the same length. Lists do not have that limitation, they are more flexible. So, lists. We’ll have to learn how to live with them. d1 &lt;- d %&gt;% subset(noise == 0 &amp; rate == 0.8) ## Create the data. N.B. note the two variables have different lengths: 1 for n, n for h. data &lt;- list( n = 120, # n of trials h = d1$choice # sequence of choices (h stands for hand) ) 4.3.2 Model We write the stan code within the R code (so I can show it to you more easily), then we save it as a stan file, which can be loaded at a later stage in order to compile it. [Missing: more info on compiling etc.] Remember that the minimal Stan model requires 3 chunks, one specifying the data it will need as input; one specifying the parameters to be estimated; one specifying the model within which the parameters appear, and the priors for those parameters. stan_model &lt;- &quot; // This model infers a random bias from a sequences of 1s and 0s (right and left hand choices) // The input (data) for the model. n of trials and the sequence of choices (right as 1, left as 0) data { int&lt;lower=1&gt; n; // n of trials array[n] int h; // sequence of choices (right as 1, left as 0) as long as n } // The parameters that the model needs to estimate (theta) parameters { real&lt;lower=0, upper=1&gt; theta; // rate or theta is a probability and therefore bound between 0 and 1 } // The model to be estimated (a bernoulli, parameter theta, prior on the theta) model { // The prior for theta is a beta distribution alpha of 1, beta of 1, equivalent to a uniform between 0 and 1 target += beta_lpdf(theta | 1, 1); // The model consists of a bernoulli distribution (binomial w 1 trial only) with a rate theta target += bernoulli_lpmf(h | theta); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W3_SimpleBernoulli.stan&quot;) 4.3.3 Compiling and fitting the model ## Specify where the model is file &lt;- file.path(&quot;stan/W3_SimpleBernoulli.stan&quot;) # Compile the model mod &lt;- cmdstan_model(file, # this specifies we can parallelize the gradient estimations on multiple cores cpp_options = list(stan_threads = TRUE), # this is a trick to make it faster stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, # the data :-) seed = 123, # a seed, so I always get the same results chains = 2, # how many chains should I fit (to check whether they give the same results) parallel_chains = 2, # how many of the chains can be run in parallel? threads_per_chain = 2, # distribute gradient estimations within chain across multiple cores iter_warmup = 1000, # warmup iterations through which hyperparameters (steps and step length) are adjusted iter_sampling = 2000, # total number of iterations refresh = 0, # how often to show that iterations have been run output_dir = &quot;simmodels&quot;, # saves the samples as csv so it can be later loaded max_treedepth = 20, # how many steps in the future to check to avoid u-turns adapt_delta = 0.99, # how high a learning rate to adjust hyperparameters during warmup ) # Same the fitted model samples$save_object(&quot;simmodels/W3_SimpleBernoulli.rds&quot;) 4.3.4 Summarizing the model Now the model is ready to be assessed. First we simply generate a summary of the estimates to have a first idea. samples &lt;- readRDS(&quot;simmodels/W3_SimpleBernoulli.rds&quot;) samples$summary() # summarize the model ## # A tibble: 2 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -70.7 -70.4 0.711 0.320 -72.2 -70.2 1.00 1066. 1106. ## 2 theta 0.739 0.740 0.0396 0.0400 0.672 0.802 1.00 938. 1077. 4.3.5 Assessing model quality Then we need to look more in the details at the quality of the estimation: * the markov chains * how the prior and the posterior estimates relate to each other (whether the prior is constraining the posterior estimate) # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples$draws()) # Checking the model&#39;s chains ggplot(draws_df, aes(.iteration, theta, group = .chain, color = .chain)) + geom_line() + theme_classic() # add a prior for theta (ugly, but we&#39;ll do better soon) draws_df &lt;- draws_df %&gt;% mutate( theta_prior = rbeta(nrow(draws_df), 1, 1) ) # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(theta), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(theta_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.8, linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 1.5) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() As we can see from the posterior estimates and the prior posterior update check, our model is doing a decent job. It doesn’t exactly reconstruct the rate of 0.8, but 0.755 is pretty close and 0.8 is included within the credible interval. Now we build the same model, but using the log odds scale for the theta parameter, which will become useful later when we condition theta on variables and build multilevel models (as we can do what we want in a log odds space and it will always be bound between 0 and 1). stan_model &lt;- &quot; // This model infers a random bias from a sequences of 1s and 0s (right and left hand choices) // The input (data) for the model. n of trials and the sequence of choices (right as 1, left as 0) data { int&lt;lower=1&gt; n; // n of trials array[n] int h; // sequence of choices (right as 1, left as 0) as long as n } // The parameters that the model needs to estimate (theta) parameters { real theta; // note it is unbounded as we now work on log odds } // The model to be estimated (a bernoulli, parameter theta, prior on the theta) model { // The prior for theta on a log odds scale is a normal distribution with a mean of 0 and a sd of 1. // This covers most of the probability space between 0 and 1, after being converted to probability. target += normal_lpdf(theta | 0, 1); // The model consists of a bernoulli distribution (binomial w 1 trial only) with a rate theta, // note we specify it uses a logit link (theta is in logodds) target += bernoulli_logit_lpmf(h | theta); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W3_SimpleBernoulli_logodds.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W3_SimpleBernoulli_logodds.stan&quot; ## With the logit format ## Specify where the model is file &lt;- file.path(&quot;stan/W3_SimpleBernoulli_logodds.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, output_dir = &quot;simmodels&quot;, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 finished in 0.1 seconds. ## Chain 2 finished in 0.1 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 0.1 seconds. ## Total execution time: 0.1 seconds. # Same the fitted model samples$save_object(&quot;simmodels/W3_SimpleBernoulli_logodds.rds&quot;) 4.3.6 Summarizing the results samples &lt;- readRDS(&quot;simmodels/W3_SimpleBernoulli_logodds.rds&quot;) # Diagnostics samples$cmdstan_diagnose() ## Processing csv files: /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W3_SimpleBernoulli_logodds-202303240927-1-09451b.csv, /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W3_SimpleBernoulli_logodds-202303240927-2-09451b.csv ## ## Checking sampler transitions treedepth. ## Treedepth satisfactory for all transitions. ## ## Checking sampler transitions for divergences. ## No divergent transitions found. ## ## Checking E-BFMI - sampler transitions HMC potential energy. ## E-BFMI satisfactory. ## ## Effective sample size satisfactory. ## ## Split R-hat values satisfactory all parameters. ## ## Processing complete, no problems detected. # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples$draws()) ggplot(draws_df, aes(.iteration, theta, group = .chain, color = .chain)) + geom_line() + theme_classic() # add a prior for theta (ugly, but we&#39;ll do better soon) draws_df &lt;- draws_df %&gt;% mutate( theta_prior = rnorm(nrow(draws_df), 0, 1) ) # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(theta), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(theta_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.8, linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 1.5) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() # Summary samples$summary() ## # A tibble: 2 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -61.0 -60.8 0.748 0.302 -62.4 -60.5 1.00 1012. 989. ## 2 theta 1.37 1.37 0.225 0.219 1.01 1.75 1.00 655. 896. We can see that the results are very similar. 4.4 Parameter recovery Now that we see that the model works in one case, we can run it throughout all possible rate and noise levels in the simulation. N.B. here is using loops, parallelized version in the next code chunk. # Now we need to scale it up to all possible rates and noises recovery_df &lt;- NULL for (noiseLvl in unique(d$noise)) { for (rateLvl in unique(d$rate)) { dd &lt;- d %&gt;% subset( noise == noiseLvl &amp; rate == rateLvl ) data &lt;- list( n = 120, h = dd$choice ) samples &lt;- mod$sample( data = data, seed = 123, chains = 1, parallel_chains = 1, threads_per_chain = 1, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) draws_df &lt;- as_draws_df(samples$draws()) temp &lt;- tibble(biasEst = inv_logit_scaled(draws_df$theta), biasTrue = rateLvl, noise = noiseLvl) if (exists(&quot;recovery_df&quot;)) {recovery_df &lt;- rbind(recovery_df, temp)} else {recovery_df &lt;- temp} } } write_csv(recovery_df, &quot;simdata/W3_recoverydf_simple.csv&quot;) Now we can look at the relation between the “true” bias value we inputted in the simulation and the inferred bias value - the posterior estimates of bias. recovery_df &lt;- read_csv(&quot;simdata/W3_recoverydf_simple.csv&quot;) ## Rows: 132000 Columns: 3 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (3): biasEst, biasTrue, noise ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ggplot(recovery_df, aes(biasTrue, biasEst)) + geom_point(alpha = 0.1) + geom_smooth() + facet_wrap(.~noise) + theme_classic() ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; There’s much to be said about the final plot, but for now let’s just say that it looks good. We can reconstruct in a nice ordered way true rate values. However, our ability to do so decreases with the increase in noise. So far no surprises. Wait, you say, shouldn’t we actually model the generative process, that is, include noise in the Stan model? Gold star, there! But let’s wait a bit before we get there, we’ll need mixture models. One final note before moving to the memory model: what if we parallelized the parameter recovery, so that different models / datasets run on different cores? This was not necessary above (it ran in a few minutes anyway), but will become crucial with more complex models. To parallelize, we rely on furrr, a neat R package that distributes parallel operations across cores. First we need to define the function that will define the operations to be run on each core separately, here we simulate the data according to a seed, a n of trials, a rate and a noise, and then we fit the model to them. Second, we need to create a tibble of the seeds, n of trials, rate and noise values that should be simulated. Third, we use future_pmap_dfr to run the function on each row of the tibble above separately on a different core. Note that I set the system to split across 4 parallel cores (to work on my computer without clogging it). Do change it according to the system you are using. Note that if you have 40 “jobs” (rows of the tibble, sets of parameter values to run), using e.g. 32 cores will not substantially speed things more than using 20. pacman::p_load(future, purrr, furrr) plan(multisession, workers = 4) sim_d_and_fit &lt;- function(seed, trials, rateLvl, noiseLvl) { for (t in seq(trials)) { # looping through trials (to make it homologous to more reactive models) randomChoice[t] &lt;- RandomAgentNoise_f(rateLvl, noiseLvl) } temp &lt;- tibble(trial = seq(trials), choice = randomChoice, rate, noise) data &lt;- list( n = 120, h = temp$choice ) samples &lt;- mod$sample( data = data, seed = 1000, chains = 1, parallel_chains = 1, threads_per_chain = 1, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) draws_df &lt;- as_draws_df(samples$draws()) temp &lt;- tibble(biasEst = inv_logit_scaled(draws_df$theta), biasTrue = rateLvl, noise = noiseLvl) return(temp) } temp &lt;- tibble(unique(d[,c(&quot;rate&quot;, &quot;noise&quot;)])) %&gt;% mutate(seed = 1000, trials = 120) %&gt;% rename(rateLvl = rate, noiseLvl = noise) recovery_df &lt;- future_pmap_dfr(temp, sim_d_and_fit, .options = furrr_options(seed = TRUE)) write_csv(recovery_df, &quot;simdata/W3_recoverydf_parallel.csv&quot;) And now we load the data and visualize it as before. recovery_df &lt;- read_csv(&quot;simdata/W3_recoverydf_parallel.csv&quot;) ## Rows: 132000 Columns: 3 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (3): biasEst, biasTrue, noise ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ggplot(recovery_df, aes(biasTrue, biasEst)) + geom_point(alpha = 0.1) + geom_smooth() + facet_wrap(.~noise) + theme_classic() ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 4.5 The memory model: conditioning theta Now that we fitted the base model, we can move onto more complex models. For instance a memory model (including all previous trials). Here we rely on a generalized linear model kind of thinking: the theta is the expression of a linear model (bias + b1 * PreviousRate). To make the variable more intuitive we code previous rate - which is bound to a probability 0-1 space - into log-odds via a logit link/transformation. In this way a previous rate with more left than right choices will result in a negative value, thereby decreasing our propensity to choose right; and one with more right than left choices will result in a positive value, thereby increasing our propensity to choose right. # We subset to only include no noise and a specific rate d1 &lt;- d %&gt;% subset(noise == 0 &amp; rate == 0.8) %&gt;% rename(Other = choice) %&gt;% mutate(cumulativerate = lag(cumulativerate, 1)) d1$cumulativerate[1] &lt;- 0.5 # no prior info at first trial d1$cumulativerate[d1$cumulativerate == 0] &lt;- 0.01 d1$cumulativerate[d1$cumulativerate == 1] &lt;- 0.99 # Now we create the memory agent with a coefficient of 0.9 MemoryAgent_f &lt;- function(bias, beta, cumulativerate){ choice = rbinom(1, 1, inv_logit_scaled(bias + beta * cumulativerate)) return(choice) } d1$Self[1] &lt;- RandomAgentNoise_f(0.5, 0) ## Warning: Unknown or uninitialised column: `Self`. for (i in 2:trials) { d1$Self[i] &lt;- MemoryAgent_f(bias = 0, beta = 0.8, d1$cumulativerate[i]) } ## Create the data data &lt;- list( n = 120, h = d1$Self, memory = d1$cumulativerate # this creates the new parameter: the rate of right hands so far in log-odds ) stan_model &lt;- &quot; // The input (data) for the model. n of trials and h for (right and left) hand data { int&lt;lower=1&gt; n; array[n] int h; vector[n] memory; // here we add the new parameter. N.B. Log odds } // The parameters accepted by the model. parameters { real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)? real beta; // how strongly is previous rate impacting the decision? } // The model to be estimated. model { // priors target += normal_lpdf(bias | 0, .3); target += normal_lpdf(beta | 0, .5); // model target += bernoulli_logit_lpmf(h | bias + beta * logit(memory)); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W3_MemoryBernoulli.stan&quot;) ## Specify where the model is file &lt;- file.path(&quot;stan/W3_MemoryBernoulli.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 1000, refresh = 0, output_dir = &quot;simmodels&quot;, max_treedepth = 20, adapt_delta = 0.99, ) # Same the fitted model samples$save_object(&quot;simmodels/W3_MemoryBernoulli.rds&quot;) 4.5.1 Summarizing the results samples &lt;- readRDS(&quot;simmodels/W3_MemoryBernoulli.rds&quot;) # Diagnostics samples$cmdstan_diagnose() ## Processing csv files: /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W3_MemoryBernoulli-202303231303-1-3e8206.csv, /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W3_MemoryBernoulli-202303231303-2-3e8206.csv ## ## Checking sampler transitions treedepth. ## Treedepth satisfactory for all transitions. ## ## Checking sampler transitions for divergences. ## No divergent transitions found. ## ## Checking E-BFMI - sampler transitions HMC potential energy. ## E-BFMI satisfactory. ## ## Effective sample size satisfactory. ## ## Split R-hat values satisfactory all parameters. ## ## Processing complete, no problems detected. # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples$draws()) ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) + geom_line() + theme_classic() ggplot(draws_df, aes(.iteration, beta, group = .chain, color = .chain)) + geom_line() + theme_classic() # add a prior for theta (ugly, but we&#39;ll do better soon) draws_df &lt;- draws_df %&gt;% mutate( bias_prior = rnorm(nrow(draws_df), 0, .3), beta_prior = rnorm(nrow(draws_df), 0, .5), ) # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(bias), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(bias_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0, linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 1.5) + xlab(&quot;Bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(beta), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(beta_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.8, linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 1.5) + xlab(&quot;Beta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() samples$summary() ## # A tibble: 3 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -78.7 -78.4 1.02 0.734 -80.7 -77.8 1.01 564. 634. ## 2 bias 0.239 0.235 0.230 0.236 -0.130 0.616 1.00 528. 526. ## 3 beta 0.318 0.321 0.239 0.234 -0.0679 0.719 1.00 600. 656. We can see that the model has now estimated both the bias and the role of previous memory. Bias should reflect the bias in the setup (0.5 which in log odds is 0), and the beta coefficient for memory (roughly 0.8). More on the quality checks of the models in the next chapter. 4.6 Memory agent with internal parameter So far we behaved like in GLM: we keep feeding to the model an external variable of memory, but what if we coded memory as an internal parameter? This opens up to further possibilities to model how long memory is kept and weighted by distance from the current moment, etc. [Missing: discussion of the equation of the model, how it relates to Kalman filters, Rescorla-Wagner, and hierarchical gaussian filters] ## Create the data data &lt;- list( n = 120, h = d1$Self, other = d1$Other ) stan_model &lt;- &quot; // The input (data) for the model. n of trials and h for (right and left) hand data { int&lt;lower=1&gt; n; array[n] int h; array[n] int other; } // The parameters accepted by the model. parameters { real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)? real beta; // how strongly is previous rate impacting the decision? } transformed parameters{ vector[n] memory; for (trial in 1:n){ if (trial == 1) { memory[trial] = 0.5; } if (trial &lt; n){ memory[trial + 1] = memory[trial] + ((other[trial] - memory[trial]) / trial); if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;} if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;} } } } // The model to be estimated. model { // Priors target += normal_lpdf(bias | 0, .3); target += normal_lpdf(beta | 0, .5); // Model, looping to keep track of memory for (trial in 1:n) { target += bernoulli_logit_lpmf(h[trial] | bias + beta * logit(memory[trial])); } } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W3_InternalMemory.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W3_InternalMemory.stan&quot; ## Specify where the model is file &lt;- file.path(&quot;stan/W3_InternalMemory.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 1, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 1000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 1 chain, with 2 thread(s) per chain... ## ## Chain 1 finished in 0.6 seconds. samples$summary() ## # A tibble: 123 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -70.2 -70.0 0.918 0.652 -72.1 -69.4 1.01 348. 414. ## 2 bias 0.277 0.286 0.251 0.235 -0.155 0.676 1.00 345. 235. ## 3 beta 0.399 0.390 0.172 0.169 0.119 0.688 1.00 326. 328. ## 4 memory[1] 0.5 0.5 0 0 0.5 0.5 NA NA NA ## 5 memory[2] 0.99 0.99 0 0 0.99 0.99 NA NA NA ## 6 memory[3] 0.995 0.995 0 0 0.995 0.995 NA NA NA ## 7 memory[4] 0.997 0.997 0 0 0.997 0.997 NA NA NA ## 8 memory[5] 0.748 0.748 0 0 0.748 0.748 NA NA NA ## 9 memory[6] 0.798 0.798 0 0 0.798 0.798 NA NA NA ## 10 memory[7] 0.832 0.832 0 0 0.832 0.832 NA NA NA ## # … with 113 more rows Now that we know how to model memory as an internal state, we can play with making the update discount the past, setting a parameter that indicates after how many trials memory is lost, etc. 4.6.1 Trying out a more complex memory model, with a rate of forgetting that exponentially discounts the past stan_model &lt;- &quot; // The input (data) for the model. n of trials and h for (right and left) hand data { int&lt;lower=1&gt; n; array[n] int h; array[n] int other; } // The parameters accepted by the model. parameters { real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)? real beta; // how strongly is previous rate impacting the decision? real&lt;lower=0, upper=1&gt; forgetting; } // The model to be estimated. model { vector[n] memory; // Priors target += beta_lpdf(forgetting | 1, 1); target += normal_lpdf(bias | 0, .3); target += normal_lpdf(beta | 0, .5); // Model, looping to keep track of memory for (trial in 1:n) { if (trial == 1) { memory[trial] = 0.5; } target += bernoulli_logit_lpmf(h[trial] | bias + beta * logit(memory[trial])); if (trial &lt; n){ memory[trial + 1] = (1 - forgetting) * memory[trial] + forgetting * other[trial]; if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;} if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;} } } } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W3_InternalMemory2.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W3_InternalMemory2.stan&quot; ## Specify where the model is file &lt;- file.path(&quot;stan/W3_InternalMemory2.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 1, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 1000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 1 chain, with 2 thread(s) per chain... ## ## Chain 1 finished in 2.5 seconds. samples$summary() ## # A tibble: 4 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -71.8 -71.4 1.23 0.931 -74.1 -70.5 1.00 341. 486. ## 2 bias 0.390 0.386 0.229 0.231 0.0281 0.769 1.00 391. 375. ## 3 beta 0.324 0.301 0.195 0.209 0.0559 0.681 1.00 253. 387. ## 4 forgetting 0.316 0.247 0.221 0.188 0.0554 0.756 1.00 140. 169. knitr::opts_chunk$set(echo = TRUE) "],["practical-exercise-4---model-quality-checks.html", "Chapter 5 Practical exercise 4 - Model quality checks 5.1 Generating and plotting additional variables 5.2 Assessing priors 5.3 Assessing prior and posterior predictions 5.4 Prior sensitivity analysis 5.5 The memory model 5.6 Prior sensitivity check for the memory model", " Chapter 5 Practical exercise 4 - Model quality checks This document covers: - generating and plotting priors (against posteriors) - generating and plotting predictive checks (prior and posterior ones) - prior sensitivity checks 5.1 Generating and plotting additional variables As we try to understand our model, we might want to plot how the prior relates to the posterior, or - in other words, what has the model learned from looking at the data? We can do so by overlaying the prior and the posterior distributions, what is also called a “prior - posterior update check”. Stan does not automatically save the prior distribution, so we need to tell it to generate and save prior distributions in a convenient place so we can easily plot or use them at will from R. Luckily, Stan gives us a dedicated code chunk to do that: the generated quantities chunk. As before, we need to define the kind of variable we want to save, and then how to generate it. If we take the example of the random agent (with a bias), we have one parameter: theta. We can then generate theta according to the prior in generated quantities. While we are at this, we can also generate a nicer version of the posterior estimate for the theta parameter, now in probability scale (instead of log odds). However, prior and posterior estimates are not always the most immediate thing to understand. For instance, we might have trouble having a good grasp for how the uncertainty in the estimate will play out on 120 trials, or 6 trials, or however many trials we are planning for our experiment. Luckily, we can ask Stan to run predictions from either priors or posteriors, or both: given the priors how many trials will have “right hand” choice? and given the posterior estimates? As we use complex models, the relation between prior/posterior estimates and predictions becomes less and less intuitive. Simulating their implications for the outcomes - also called prior/posterior predictive checks - becomes a very useful tool to adjust our priors and their uncertainty so that they reflect what we know of the outcome scale; as well as to assess whether the model (and its posterior estimates) can appropriately describe the data we observe, or there’s some bias there. More discussion of this can be found at https://4ccoxau.github.io/PriorsWorkshop/. pacman::p_load(tidyverse, here, posterior, cmdstanr, brms, tidybayes) d &lt;- read_csv(&quot;simdata/W3_randomnoise.csv&quot;) stan_model &lt;- &quot; // This model infers a random bias from a sequences of 1s and 0s (right and left hand choices) // The input (data) for the model. n of trials and the sequence of choices (right as 1, left as 0) data { int&lt;lower=1&gt; n; // n of trials array[n] int h; // sequence of choices (right as 1, left as 0) as long as n } // The parameters that the model needs to estimate (theta) parameters { real theta; // note it is unbounded as we now work on log odds } // The model to be estimated (a bernoulli, parameter theta, prior on the theta) model { // The prior for theta on a log odds scale is a normal distribution with a mean of 0 and a sd of 1. // This covers most of the probability space between 0 and 1, after being converted to probability. target += normal_lpdf(theta | 0, 1); // The model consists of a bernoulli distribution (binomial w 1 trial only) with a rate theta, // note we specify it uses a logit link (theta is in logodds) target += bernoulli_logit_lpmf(h | theta); } generated quantities{ real&lt;lower=0, upper=1&gt; theta_prior; // theta prior parameter, on a prob scale (0-1) real&lt;lower=0, upper=1&gt; theta_posterior; // theta posterior parameter, on a prob scale (0-1) int&lt;lower=0, upper=n&gt; prior_preds; // distribution of right hand choices according to the prior int&lt;lower=0, upper=n&gt; posterior_preds; // distribution of right hand choices according to the posterior theta_prior = inv_logit(normal_rng(0,1)); // generating the prior on a log odds scale and converting theta_posterior = inv_logit(theta); // converting the posterior estimate from log odds to prob. prior_preds = binomial_rng(n, theta_prior); posterior_preds = binomial_rng(n, inv_logit(theta)); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W4_SimpleBernoulli_logodds.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W4_SimpleBernoulli_logodds.stan&quot; ## With the logit format ## Specify where the model is file &lt;- file.path(&quot;stan/W4_SimpleBernoulli_logodds.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) d1 &lt;- d %&gt;% subset(noise == 0 &amp; rate == 0.8) ## Create the data. N.B. note the two variables have different lengths: 1 for n, n for h. data &lt;- list( n = 120, # n of trials h = d1$choice # sequence of choices (h stands for hand) ) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 finished in 0.1 seconds. ## Chain 2 finished in 0.1 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 0.1 seconds. ## Total execution time: 0.1 seconds. draws_df &lt;- as_draws_df(samples$draws()) 5.2 Assessing priors # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(theta_posterior), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(theta_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.8, linetype = &quot;dashed&quot;, color = &quot;black&quot;, size = 1.5) + xlab(&quot;Rate&quot;) + ylab(&quot;Estimate Densities&quot;) + theme_classic() 5.3 Assessing prior and posterior predictions ggplot(draws_df) + geom_histogram(aes(prior_preds), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(posterior_preds), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3, bins = 90) + geom_point(x = sum(data$h), y = 0, color = &quot;red&quot;, shape = 17, size = 5) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(prior_preds), color = &quot;lightblue&quot;, fill = &quot;blue&quot;, alpha = 0.3, bins = 90) + geom_histogram(aes(posterior_preds), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3, bins = 90) + geom_point(x = sum(data$h), y = 0, color = &quot;red&quot;, shape = 17, size = 5) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() 5.4 Prior sensitivity analysis ## Now we adding different priors for theta prior_mean &lt;- seq(-3, 3, .5) prior_sd &lt;- seq(0.1, 1, 0.1) priors &lt;- expand.grid(prior_mean, prior_sd) priors &lt;- tibble(prior_mean = priors$Var1, prior_sd = priors$Var2) stan_model &lt;- &quot; // The input (data) for the model data { int&lt;lower=1&gt; n; array[n] int h; real prior_mean; real&lt;lower=0&gt; prior_sd; } // The parameters accepted by the model. parameters { real theta; } // The model to be estimated. model { // Prior target += normal_lpdf(theta | prior_mean, prior_sd); // Model target += bernoulli_logit_lpmf(h | theta); } generated quantities{ real&lt;lower=0, upper=1&gt; theta_prior; real&lt;lower=0, upper=1&gt; theta_posterior; int&lt;lower=0, upper=n&gt; prior_preds; int&lt;lower=0, upper=n&gt; posterior_preds; theta_prior = inv_logit(normal_rng(0,1)); theta_posterior = inv_logit(theta); prior_preds = binomial_rng(n, theta_prior); posterior_preds = binomial_rng(n, inv_logit(theta)); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W4_PriorBernoulli.stan&quot;) file &lt;- file.path(&quot;stan/W4_PriorBernoulli.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) dd &lt;- d %&gt;% subset(noise == 0.1 &amp; rate == 0.8) pacman::p_load(future, purrr, furrr) plan(multisession, workers = 4) sim_d_and_fit &lt;- function(prior_mean, prior_sd) { data &lt;- list( n = nrow(dd), h = dd$choice, prior_mean = prior_mean, prior_sd = prior_sd ) samples &lt;- mod$sample( data = data, seed = 1000, chains = 1, parallel_chains = 1, threads_per_chain = 1, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) draws_df &lt;- as_draws_df(samples$draws()) temp &lt;- tibble(theta_prior = draws_df$theta_prior, theta_posterior = draws_df$theta_posterior, prior_preds = draws_df$prior_preds, posterior_preds = draws_df$posterior_preds, prior_mean = prior_mean, prior_sd = prior_sd) return(temp) } recovery_df &lt;- future_pmap_dfr(priors, sim_d_and_fit, .options = furrr_options(seed = TRUE)) write_csv(recovery_df, &quot;simdata/W4_priorSensitivityRecovery.csv&quot;) Now we load the data and plot it recovery_df &lt;- read_csv(&quot;simdata/W4_priorSensitivityRecovery.csv&quot;) ## Rows: 260000 Columns: 6 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (6): theta_prior, theta_posterior, prior_preds, posterior_preds, prior_mean, prior_sd ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ggplot(recovery_df, aes(prior_mean, theta_posterior)) + geom_point(alpha = 0.1) + geom_hline(yintercept = 0.8, color = &quot;red&quot;) + geom_smooth() + facet_wrap(.~prior_sd) + theme_classic() ## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 5.5 The memory model We can do the same for the memory model: generate prior distributions to overlay to the posteriors (prior-posterior update checks), generate predicted outcomes based on the priors (prior predictive checks) and on the posteriors (posterior predictive checks). N.B. prior and posterior predictions now depend on the value on memory. I identified 3 meaningful values for the memory value (e.g. 0.5, 0.7, 0.9) and used those to generate 3 prior and posterior predictive checks. # We subset to only include no noise and a specific rate d1 &lt;- d %&gt;% subset(noise == 0 &amp; rate == 0.8) %&gt;% rename(Other = choice) %&gt;% mutate(cumulativerate = lag(cumulativerate, 1)) d1$cumulativerate[1] &lt;- 0.5 # no prior info at first trial d1$cumulativerate[d1$cumulativerate == 0] &lt;- 0.01 d1$cumulativerate[d1$cumulativerate == 1] &lt;- 0.99 # Now we create the memory agent with a coefficient of 0.9 bias = 0 beta = 0.9 MemoryAgent_f &lt;- function(bias, beta, cumulativerate){ choice = rbinom(1, 1, inv_logit_scaled(bias + beta * logit_scaled(cumulativerate))) return(choice) } for (i in 1:trials) { d1$Self[i] &lt;- MemoryAgent_f(bias, beta, d1$cumulativerate[i]) } ## Create the data. data &lt;- list( n = 120, h = d1$Self, other = d1$Other ) stan_model &lt;- &quot; // The input (data) for the model. n of trials and h for (right and left) hand data { int&lt;lower=1&gt; n; array[n] int h; array[n] int other; } // The parameters accepted by the model. parameters { real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)? real beta; // how strongly is previous rate impacting the decision? } transformed parameters{ vector[n] memory; for (trial in 1:n){ if (trial == 1) { memory[trial] = 0.5; } if (trial &lt; n){ memory[trial + 1] = memory[trial] + ((other[trial] - memory[trial]) / trial); if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;} if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;} } } } // The model to be estimated. model { // Priors target += normal_lpdf(bias | 0, .3); target += normal_lpdf(beta | 0, .5); // Model, looping to keep track of memory for (trial in 1:n) { target += bernoulli_logit_lpmf(h[trial] | bias + beta * logit(memory[trial])); } } generated quantities{ real bias_prior; real beta_prior; int&lt;lower=0, upper=n&gt; prior_preds5; int&lt;lower=0, upper=n&gt; post_preds5; int&lt;lower=0, upper=n&gt; prior_preds7; int&lt;lower=0, upper=n&gt; post_preds7; int&lt;lower=0, upper=n&gt; prior_preds9; int&lt;lower=0, upper=n&gt; post_preds9; bias_prior = normal_rng(0, 0.3); beta_prior = normal_rng(0, 0.5); prior_preds5 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.5))); prior_preds7 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.7))); prior_preds9 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.9))); post_preds5 = binomial_rng(n, inv_logit(bias + beta * logit(0.5))); post_preds7 = binomial_rng(n, inv_logit(bias + beta * logit(0.7))); post_preds9 = binomial_rng(n, inv_logit(bias + beta * logit(0.9))); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W4_MemoryBernoulli.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W4_MemoryBernoulli.stan&quot; ## Specify where the model is file &lt;- file.path(&quot;stan/W4_MemoryBernoulli.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 1, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1000, iter_sampling = 1000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 1 chain, with 2 thread(s) per chain... ## ## Chain 1 finished in 0.7 seconds. samples$summary() ## # A tibble: 131 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -57.1 -56.7 0.950 0.659 -59.1 -56.1 1.00 401. 474. ## 2 bias 0.175 0.184 0.270 0.279 -0.294 0.599 1.01 179. 402. ## 3 beta 0.764 0.766 0.201 0.202 0.454 1.10 1.01 174. 337. ## 4 memory[1] 0.5 0.5 0 0 0.5 0.5 NA NA NA ## 5 memory[2] 0.99 0.99 0 0 0.99 0.99 NA NA NA ## 6 memory[3] 0.995 0.995 0 0 0.995 0.995 NA NA NA ## 7 memory[4] 0.997 0.997 0 0 0.997 0.997 NA NA NA ## 8 memory[5] 0.748 0.748 0 0 0.748 0.748 NA NA NA ## 9 memory[6] 0.798 0.798 0 0 0.798 0.798 NA NA NA ## 10 memory[7] 0.832 0.832 0 0 0.832 0.832 NA NA NA ## # … with 121 more rows # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples$draws()) # Now let&#39;s plot the density for bias (prior and posterior) ggplot(draws_df) + geom_density(aes(bias), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(bias_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0, size = 2) + xlab(&quot;Bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(beta), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(beta_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.9, size = 2) + xlab(&quot;MemoryBeta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(`prior_preds5`), color = &quot;yellow&quot;, fill = &quot;lightyellow&quot;, alpha = 0.2) + geom_histogram(aes(`prior_preds7`), color = &quot;green&quot;, fill = &quot;lightgreen&quot;, alpha = 0.2) + geom_histogram(aes(`prior_preds9`), color = &quot;blue&quot;, fill = &quot;lightblue&quot;, alpha = 0.2) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(`post_preds5`), color = &quot;yellow&quot;, fill = &quot;lightyellow&quot;, alpha = 0.3, bins = 90) + geom_histogram(aes(`post_preds7`), color = &quot;green&quot;, fill = &quot;lightgreen&quot;, alpha = 0.3, bins = 90) + geom_histogram(aes(`post_preds9`), color = &quot;blue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3, bins = 90) + #geom_point(x = sum(data$h), y = 0, color = &quot;red&quot;, shape = 17, size = 5) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(`prior_preds5`), color = &quot;lightblue&quot;, fill = &quot;blue&quot;, alpha = 0.3, bins = 90) + geom_histogram(aes(`post_preds5`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3, bins = 90) + xlab(&quot;Predicted heads out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() 5.6 Prior sensitivity check for the memory model ## Now we adding different priors for theta prior_mean_bias &lt;- 0 prior_sd_bias &lt;- seq(0.1, 0.5, 0.1) prior_mean_beta &lt;- 0 prior_sd_beta &lt;- seq(0.1, 0.5, 0.1) priors &lt;- tibble(expand.grid(tibble(prior_mean_bias, prior_sd_bias, prior_mean_beta, prior_sd_beta))) stan_model &lt;- &quot; // The input (data) for the model data { int&lt;lower=1&gt; n; array[n] int h; array[n] int other; real prior_mean_bias; real&lt;lower=0&gt; prior_sd_bias; real prior_mean_beta; real&lt;lower=0&gt; prior_sd_beta; } // The parameters accepted by the model. parameters { real bias; // how likely is the agent to pick right when the previous rate has no information (50-50)? real beta; // how strongly is previous rate impacting the decision? } transformed parameters{ vector[n] memory; for (trial in 1:n){ if (trial == 1) { memory[trial] = 0.5; } if (trial &lt; n){ memory[trial + 1] = memory[trial] + ((other[trial] - memory[trial]) / trial); if (memory[trial + 1] == 0){memory[trial + 1] = 0.01;} if (memory[trial + 1] == 1){memory[trial + 1] = 0.99;} } } } // The model to be estimated. model { // The priors target += normal_lpdf(bias | prior_mean_bias, prior_sd_bias); target += normal_lpdf(beta | prior_mean_beta, prior_sd_beta); // The model target += bernoulli_logit_lpmf(h | bias + beta * logit(memory)); } generated quantities{ real bias_prior; real beta_prior; int&lt;lower=0, upper=n&gt; prior_preds5; int&lt;lower=0, upper=n&gt; post_preds5; int&lt;lower=0, upper=n&gt; prior_preds7; int&lt;lower=0, upper=n&gt; post_preds7; int&lt;lower=0, upper=n&gt; prior_preds9; int&lt;lower=0, upper=n&gt; post_preds9; bias_prior = normal_rng(prior_mean_bias, prior_sd_bias); beta_prior = normal_rng(prior_mean_beta, prior_sd_beta); prior_preds5 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.5))); prior_preds7 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.7))); prior_preds9 = binomial_rng(n, inv_logit(bias_prior + beta_prior * logit(0.9))); post_preds5 = binomial_rng(n, inv_logit(bias + beta * logit(0.5))); post_preds7 = binomial_rng(n, inv_logit(bias + beta * logit(0.7))); post_preds9 = binomial_rng(n, inv_logit(bias + beta * logit(0.9))); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W4_PriorMemory.stan&quot;) file &lt;- file.path(&quot;stan/W4_PriorMemory.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE)) dd &lt;- d %&gt;% subset(noise == 0.1 &amp; rate == 0.8) %&gt;% mutate(memory = lag(cumulativerate, 1)) dd$memory[1] &lt;- 0.5 pacman::p_load(future, purrr, furrr) plan(multisession, workers = 4) sim_d_and_fit &lt;- function(prior_mean_bias, prior_sd_bias, prior_mean_beta, prior_sd_beta) { data &lt;- list( n = nrow(dd), h = dd$choice, memory = dd$memory, prior_mean_bias = prior_mean_bias, prior_sd_bias = prior_sd_bias, prior_mean_beta = prior_mean_beta, prior_sd_beta = prior_sd_beta ) samples &lt;- mod$sample( data = data, seed = 1000, chains = 1, parallel_chains = 1, threads_per_chain = 1, iter_warmup = 1000, iter_sampling = 2000, refresh = 0, max_treedepth = 20, adapt_delta = 0.99, ) draws_df &lt;- as_draws_df(samples$draws()) temp &lt;- tibble(bias_prior = draws_df$bias_prior, beta_prior = draws_df$beta_prior, bias_posterior = draws_df$bias, beta_posterior = draws_df$beta, prior_preds5 = draws_df$prior_preds5, prior_preds7 = draws_df$prior_preds7, prior_preds9 = draws_df$prior_preds9, posterior_preds5 = draws_df$post_preds5, posterior_preds7 = draws_df$post_preds7, posterior_preds9 = draws_df$post_preds9, prior_mean_bias = prior_mean_bias, prior_sd_bias = prior_sd_bias, prior_mean_beta = prior_mean_beta, prior_sd_beta = prior_sd_beta) return(temp) } recovery_df &lt;- future_pmap_dfr(priors, sim_d_and_fit, .options = furrr_options(seed = TRUE)) write_csv(recovery_df, &quot;simdata/W4_MemoryPriorSensitivity.csv&quot;) recovery_df &lt;- read_csv(&quot;simdata/W4_MemoryPriorSensitivity.csv&quot;) ## Rows: 1250000 Columns: 14 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (14): bias_prior, beta_prior, bias_posterior, beta_posterior, prior_preds5, prior_preds7, prior_p... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ggplot(recovery_df, aes(prior_sd_beta, beta_posterior)) + geom_point(alpha = 0.1) + geom_hline(yintercept = 0.8, color = &quot;red&quot;) + geom_smooth(method = lm) + facet_wrap(.~prior_sd_bias) + theme_classic() ## `geom_smooth()` using formula = &#39;y ~ x&#39; "],["multilevel-modeling.html", "Chapter 6 Multilevel modeling 6.1 Intro to multilevel modeling 6.2 A multilevel version of the biased agent and of the simple memory agent 6.3 Generating the agents 6.4 Plotting the agents 6.5 Coding the multilevel agents 6.6 Multilevel full pooling", " Chapter 6 Multilevel modeling 6.1 Intro to multilevel modeling [Explanation on what multilevel modeling is - structure in the data, partial pooling, repeated measures] 6.2 A multilevel version of the biased agent and of the simple memory agent We are now conceptualizing our agents as being part of (sampled from) a more general population. This general population is characterized by a population level average parameter value (e.g. a general bias of 0.8 as we all like right hands more) and a certain variation in the population (e.g. a standard deviation of 0.1, as we are all a bit different from each other). Each biased agent’s rate is then sampled from that distribution. Same for the memory agents. [MISSING: DAG PLOTS OF THE TWO SCENARIOS] Again, it’s practical to work in log odds. Why? Well, it’s not unconceivable that an agent would be 3 sd from the mean. So a biased agent could have a rate of 0.8 + 3 * 0.1, which gives a rate of 1.1. It’s kinda impossible to choose 110% of the time the right hand. We want an easy way to avoid these situations without too carefully tweaking our parameters, or including exception statements (e.g. if rate &gt; 1, then rate = 1). Conversion to log odds is again a wonderful way to work in a boundless space, and in the last step shrinking everything back to 0-1 probability space. N.B. we model all agents with some added noise as we assume it cannot be eliminated from our studies. pacman::p_load(tidyverse, here, posterior, cmdstanr, brms, tidybayes) # Shared parameters agents &lt;- 100 trials &lt;- 120 noise &lt;- 0 # Biased agents parameters rateM &lt;- 1.386 # roughly 0.8 once inv_logit scaled rateSD &lt;- 0.65 # roughly giving a sd of 0.1 in prob scale # Memory agents parameters biasM &lt;- 0 biasSD &lt;- 0.1 betaM &lt;- 1.5 betaSD &lt;- 0.3 # Functions of the agents RandomAgentNoise_f &lt;- function(rate, noise) { choice &lt;- rbinom(1, 1, inv_logit_scaled(rate)) if (rbinom(1, 1, noise) == 1) { choice = rbinom(1, 1, 0.5) } return(choice) } MemoryAgentNoise_f &lt;- function(bias, beta, otherRate, noise) { rate &lt;- inv_logit_scaled(bias + beta * logit_scaled(otherRate)) choice &lt;- rbinom(1, 1, rate) if (rbinom(1, 1, noise) == 1) { choice = rbinom(1, 1, 0.5) } return(choice) } 6.3 Generating the agents [MISSING: PARALLELIZE] # Looping through all the agents to generate the data. d &lt;- NULL for (agent in 1:agents) { rate &lt;- rnorm(1, rateM, rateSD) bias &lt;- rnorm(1, biasM, biasSD) beta &lt;- rnorm(1, betaM, betaSD) randomChoice &lt;- rep(NA, trials) memoryChoice &lt;- rep(NA, trials) memoryRate &lt;- rep(NA, trials) for (trial in 1:trials) { randomChoice[trial] &lt;- RandomAgentNoise_f(rate, noise) if (trial == 1) { memoryChoice[trial] &lt;- rbinom(1,1,0.5) } else { memoryChoice[trial] &lt;- MemoryAgentNoise_f(bias, beta, mean(randomChoice[1:trial], na.rm = T), noise) } } temp &lt;- tibble(agent, trial = seq(trials), randomChoice, randomRate = rate, memoryChoice, memoryRate, noise, rateM, rateSD, bias, beta, biasM, biasSD, betaM, betaSD) if (agent &gt; 1) { d &lt;- rbind(d, temp) } else{ d &lt;- temp } } d &lt;- d %&gt;% group_by(agent) %&gt;% mutate( randomRate = cumsum(randomChoice) / seq_along(randomChoice), memoryRate = cumsum(memoryChoice) / seq_along(memoryChoice) ) 6.4 Plotting the agents # A plot of the proportion of right hand choices for the random agents p1 &lt;- ggplot(d, aes(trial, randomRate, group = agent, color = agent)) + geom_line(alpha = 0.5) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + theme_classic() # A plot of the proportion of right hand choices for the memory agents p2 &lt;- ggplot(d, aes(trial, memoryRate, group = agent, color = agent)) + geom_line(alpha = 0.5) + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + theme_classic() p1 + p2 # A plot of whether memory and random agents are matched in proportion at different stages p3 &lt;- d %&gt;% subset(trial == 10) %&gt;% ggplot(aes(randomRate, memoryRate)) + geom_point() + geom_smooth(method = lm) + geom_abline(intercept = 0, slope = 1, color = &quot;red&quot;) + xlim(0.25, 1) + ylim(0.25, 1) + xlab(&quot;correlation at 10 trials&quot;) + theme_bw() p4 &lt;- d %&gt;% subset(trial == 60) %&gt;% ggplot(aes(randomRate, memoryRate)) + geom_point() + geom_smooth(method = lm) + geom_abline(intercept = 0, slope = 1, color = &quot;red&quot;) + xlim(0.25, 1) + ylim(0.25, 1) + xlab(&quot;correlation at 60 trials&quot;) + theme_bw() p5 &lt;- d %&gt;% subset(trial == 120) %&gt;% ggplot(aes(randomRate, memoryRate)) + geom_point() + geom_smooth(method = lm) + geom_abline(intercept = 0, slope = 1, color = &quot;red&quot;) + xlim(0.25, 1) + ylim(0.25, 1) + xlab(&quot;correlation at 120 trials&quot;) + theme_bw() p3 + p4 + p5 ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 4 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 4 rows containing missing values (`geom_point()`). ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 4 rows containing missing values (`geom_smooth()`). ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 5 rows containing missing values (`geom_smooth()`). Note that as the n of trials increases, the memory model matches the random model better and better 6.5 Coding the multilevel agents 6.5.1 Multilevel random Remember that the simulated parameters are: * biasM &lt;- 0 * biasSD &lt;- 0.1 * betaM &lt;- 1.5 * betaSD &lt;- 0.3 Prep the data d1 &lt;- d %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) ## Create the data data &lt;- list( trials = trials, agents = agents, h = as.matrix(d1[,2:101]) ) stan_model &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (right and left). Now multilevel // functions{ real normal_lb_rng(real mu, real sigma, real lb) { // normal distribution with a lower bound real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. n of trials and h of hands data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; } // The parameters accepted by the model. parameters { real thetaM; real&lt;lower = 0&gt; thetaSD; array[agents] real theta; } // The model to be estimated. model { target += normal_lpdf(thetaM | 0, 1); target += normal_lpdf(thetaSD | 0, .3) - normal_lccdf(0 | 0, .3); // The prior for theta is a uniform distribution between 0 and 1 target += normal_lpdf(theta | thetaM, thetaSD); for (i in 1:agents) target += bernoulli_logit_lpmf(h[,i] | theta[i]); } generated quantities{ real thetaM_prior; real&lt;lower=0&gt; thetaSD_prior; real&lt;lower=0, upper=1&gt; theta_prior; real&lt;lower=0, upper=1&gt; theta_posterior; int&lt;lower=0, upper = trials&gt; prior_preds; int&lt;lower=0, upper = trials&gt; posterior_preds; thetaM_prior = normal_rng(0,1); thetaSD_prior = normal_lb_rng(0,0.3,0); theta_prior = inv_logit(normal_rng(thetaM_prior, thetaSD_prior)); theta_posterior = inv_logit(normal_rng(thetaM, thetaSD)); prior_preds = binomial_rng(trials, inv_logit(thetaM_prior)); posterior_preds = binomial_rng(trials, inv_logit(thetaM)); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelBias.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelBias.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/W5_MultilevelBias.RDS&quot;) 6.5.2 Assessing multilevel random agents Besides the usual prior predictive checks, prior posterior update checks, posterior predictive checks, based on the population level estimates; we also want to plot at least a few of the single agents to assess how well the model is doing for them. [MISSING: PLOT MODEL ESTIMATES AGAINST N OF HEADS BY PARTICIPANT] samples &lt;- readRDS(&quot;simmodels/W5_MultilevelBias.RDS&quot;) samples$cmdstan_diagnose() ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelBias-202303101235-1-84831d.csv not found ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelBias-202303101235-2-84831d.csv not found ## No valid input files, exiting. samples$summary() ## # A tibble: 109 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -5780. -5780. 7.26 7.35 -5792. -5769. 1.00 1370. 2125. ## 2 thetaM 1.49 1.49 0.0664 0.0678 1.38 1.60 1.00 7644. 3557. ## 3 thetaSD 0.637 0.634 0.0523 0.0526 0.557 0.727 1.00 5220. 3381. ## 4 theta[1] 0.663 0.661 0.184 0.188 0.366 0.968 1.00 8209. 2723. ## 5 theta[2] 0.909 0.909 0.190 0.195 0.604 1.22 1.00 10277. 2844. ## 6 theta[3] 1.28 1.27 0.216 0.213 0.932 1.64 1.00 9117. 2544. ## 7 theta[4] 2.16 2.15 0.274 0.279 1.73 2.62 1.00 8381. 2508. ## 8 theta[5] 1.51 1.50 0.217 0.214 1.16 1.86 1.00 8492. 2303. ## 9 theta[6] 2.32 2.31 0.281 0.273 1.88 2.80 1.00 9372. 2814. ## 10 theta[7] 2.10 2.09 0.275 0.267 1.66 2.57 1.00 9292. 2740. ## # … with 99 more rows draws_df &lt;- as_draws_df(samples$draws()) ggplot(draws_df, aes(.iteration, thetaM, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df, aes(.iteration, thetaSD, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df) + geom_histogram(aes(prior_preds), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Prior Density&quot;) + theme_classic() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(draws_df) + geom_density(aes(thetaM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(thetaM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 1.386) + xlab(&quot;Mean Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(thetaSD), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(thetaSD_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.65) + xlab(&quot;Variance of Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(theta_posterior), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(theta_prior), fill = &quot;red&quot;, alpha = 0.3) + xlab(&quot;Overall Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_histogram(aes(prior_preds), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(posterior_preds), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Predictive Density&quot;) + theme_classic() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(draws_df) + geom_density(aes(inv_logit_scaled(`theta[1]`)), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[15]`)), fill = &quot;green&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[21]`)), fill = &quot;lightblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[31]`)), fill = &quot;darkblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[41]`)), fill = &quot;yellow&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[51]`)), fill = &quot;darkgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`theta[61]`)), fill = &quot;lightgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(thetaM_prior)), fill = &quot;pink&quot;, alpha = 0.3) + geom_density(aes(theta_prior), fill = &quot;purple&quot;, alpha = 0.3) + xlab(&quot;Mean Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() draws_df &lt;- draws_df %&gt;% mutate( preds1 = rbinom(4000,120, inv_logit_scaled(`theta[1]`)), preds11 = rbinom(4000,120, inv_logit_scaled(`theta[11]`)), preds21 = rbinom(4000,120, inv_logit_scaled(`theta[21]`)), preds31 = rbinom(4000,120, inv_logit_scaled(`theta[31]`)), preds41 = rbinom(4000,120, inv_logit_scaled(`theta[41]`)), preds51 = rbinom(4000,120, inv_logit_scaled(`theta[51]`)), preds61 = rbinom(4000,120, inv_logit_scaled(`theta[61]`)), preds71 = rbinom(4000,120, inv_logit_scaled(`theta[71]`)), preds81 = rbinom(4000,120, inv_logit_scaled(`theta[81]`)), preds91 = rbinom(4000,120, inv_logit_scaled(`theta[91]`)), ) d2 &lt;- d %&gt;% group_by(agent) %&gt;% dplyr::summarise(right = sum(randomChoice)) ggplot(draws_df) + geom_density(aes(posterior_preds), color = &quot;skyblue1&quot;, alpha = 0.3) + geom_density(data = d2, aes(right), color = &quot;darkblue&quot;,alpha = 0.8) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p1 &lt;- ggplot(draws_df) + geom_density(aes(preds1), color = &quot;skyblue1&quot;, alpha = 0.3) + geom_point(x = subset(d2, agent == 1)$right, y = 0, shape = 23, color = &quot;darkblue&quot;, fill = &quot;darkblue&quot;) + theme_classic() p2 &lt;- ggplot(draws_df) + geom_density(aes(preds11), color = &quot;skyblue1&quot;, alpha = 0.3) + geom_point(x = subset(d2, agent == 11)$right, y = 0, shape = 23, color = &quot;darkblue&quot;, fill = &quot;darkblue&quot;) + theme_classic() p3 &lt;- ggplot(draws_df) + geom_density(aes(preds21), color = &quot;skyblue1&quot;, alpha = 0.3) + geom_point(x = subset(d2, agent == 21)$right, y = 0, shape = 23, color = &quot;darkblue&quot;, fill = &quot;darkblue&quot;) + theme_classic() library(patchwork) p1 + p2 + p3 6.5.3 Multilevel memory [MISSING: DAGS] [MISSING: EXPLAIN NEW STAN CODE] [MISSING: POP VS IND LEVEL PREDICTIONS] Prep the data ## Create the data d1 &lt;- d %&gt;% subset(select = c(agent, memoryChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = memoryChoice) d2 &lt;- d %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) data &lt;- list( trials = trials, agents = agents, h = as.matrix(d1[1:120,2:101]), other = as.matrix(d2[1:120,2:101]) ) Code, compile and fit the model stan_model &lt;- &quot; // // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { real biasM; real&lt;lower = 0&gt; biasSD; real betaM; real&lt;lower = 0&gt; betaSD; array[agents] real bias; array[agents] real beta; } transformed parameters { array[trials, agents] real memory; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(biasSD | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(betaM | 0, .3); target += normal_lpdf(betaSD | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(bias | biasM, biasSD); target += normal_lpdf(beta | betaM, betaSD); for (agent in 1:agents) for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial,agent] | bias[agent] + logit(memory[trial, agent]) * (beta[agent])); } } generated quantities{ real biasM_prior; real&lt;lower=0&gt; biasSD_prior; real betaM_prior; real&lt;lower=0&gt; betaSD_prior; real bias_prior; real beta_prior; int&lt;lower=0, upper = trials&gt; prior_preds0; int&lt;lower=0, upper = trials&gt; prior_preds1; int&lt;lower=0, upper = trials&gt; prior_preds2; int&lt;lower=0, upper = trials&gt; posterior_preds0; int&lt;lower=0, upper = trials&gt; posterior_preds1; int&lt;lower=0, upper = trials&gt; posterior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_predsID0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_predsID1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_predsID2; biasM_prior = normal_rng(0,1); biasSD_prior = normal_lb_rng(0,0.3,0); betaM_prior = normal_rng(0,1); betaSD_prior = normal_lb_rng(0,0.3,0); bias_prior = normal_rng(biasM_prior, biasSD_prior); beta_prior = normal_rng(betaM_prior, betaSD_prior); prior_preds0 = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1 = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2 = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0 = binomial_rng(trials, inv_logit(biasM + 0 * betaM)); posterior_preds1 = binomial_rng(trials, inv_logit(biasM + 1 * betaM)); posterior_preds2 = binomial_rng(trials, inv_logit(biasM + 2 * betaM)); for (agent in 1:agents){ posterior_predsID0[agent] = binomial_rng(trials, inv_logit(bias[agent] + 0 * beta[agent])); posterior_predsID1[agent] = binomial_rng(trials, inv_logit(bias[agent] + 1 * beta[agent])); posterior_predsID2[agent] = binomial_rng(trials, inv_logit(bias[agent] + 2 * beta[agent])); } } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelMemory.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelMemory.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/W5_MultilevelMemory_centered.RDS&quot;) 6.5.4 Assessing multilevel memory samples &lt;- readRDS(&quot;simmodels/W5_MultilevelMemory_centered.RDS&quot;) samples$cmdstan_diagnose() ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory-202303101235-1-8e8f81.csv not found ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory-202303101235-2-8e8f81.csv not found ## No valid input files, exiting. samples$summary(c(&quot;biasM&quot;, &quot;betaM&quot;, &quot;biasSD&quot;, &quot;betaSD&quot;)) ## # A tibble: 4 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 biasM 0.539 0.537 0.0872 0.0859 0.400 0.686 1.00 324. 718. ## 2 betaM 1.02 1.02 0.0700 0.0694 0.906 1.14 1.00 460. 1066. ## 3 biasSD 0.283 0.282 0.0672 0.0689 0.176 0.394 1.01 269. 277. ## 4 betaSD 0.410 0.407 0.0493 0.0499 0.332 0.494 1.00 1438. 2248. draws_df &lt;- as_draws_df(samples$draws()) p1 &lt;- ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) + geom_line() + theme_classic() p2 &lt;- ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) + geom_line() + theme_classic() p3 &lt;- ggplot(draws_df, aes(.iteration, betaM, group = .chain, color = .chain)) + geom_line() + theme_classic() p4 &lt;- ggplot(draws_df, aes(.iteration, betaSD, group = .chain, color = .chain)) + geom_line() + theme_classic() p1 + p2 + p3 + p4 6.5.4.1 Predictive prior checks ## ggplot(draws_df) + geom_histogram(aes(`prior_preds0`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + geom_histogram(aes(`prior_preds1`), color = &quot;darkblue&quot;, fill = &quot;green&quot;, alpha = 0.3) + geom_histogram(aes(`prior_preds2`), color = &quot;darkblue&quot;, fill = &quot;red&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 6.5.4.2 Prior posterior update checks biasM &lt;- 0 biasSD &lt;- 0.1 betaM &lt;- 1.5 betaSD &lt;- 0.3 ## p1 &lt;- ggplot(draws_df) + geom_density(aes(biasM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(biasM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0) + xlab(&quot;Mean bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p2 &lt;- ggplot(draws_df) + geom_density(aes(biasSD), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(biasSD_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.1) + xlab(&quot;Variance of bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p3 &lt;- ggplot(draws_df) + geom_density(aes(betaM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(betaM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 1.5) + xlab(&quot;Mean Beta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p4 &lt;- ggplot(draws_df) + geom_density(aes(betaSD), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(betaSD_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.3) + xlab(&quot;Variance of beta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p1 + p2 + p3 + p4 6.5.4.3 Posterior predictive checks p1 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds0`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds0`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p2 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds1`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds1`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p3 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds2`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds2`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p1 + p2 + p3 ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p1 &lt;- ggplot(draws_df, aes(biasM, biasSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p2 &lt;- ggplot(draws_df, aes(betaM, betaSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p3 &lt;- ggplot(draws_df, aes(biasM, betaM, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p4 &lt;- ggplot(draws_df, aes(biasSD, betaSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p1 + p2 + p3 + p4 6.5.5 Multilevel memory with non centered parameterization Prep the data ## Create the data d1 &lt;- d %&gt;% subset(select = c(agent, memoryChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = memoryChoice) d2 &lt;- d %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) data &lt;- list( trials = trials, agents = agents, h = as.matrix(d1[1:120,2:101]), other = as.matrix(d2[1:120,2:101]) ) Code, compile and and fit the model ## NON-CENTERED PARAMETRIZATION stan_model_nc &lt;- &quot; // // This STAN model is a multilevel memory agent // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { real biasM; real&lt;lower = 0&gt; biasSD; real betaM; real&lt;lower = 0&gt; betaSD; vector[agents] biasID_z; vector[agents] betaID_z; } transformed parameters { array[trials, agents] real memory; vector[agents] biasID; vector[agents] betaID; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } biasID = biasID_z * biasSD; betaID = betaID_z * betaSD; } // The model to be estimated. model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(biasSD | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(betaM | 0, .3); target += normal_lpdf(betaSD | 0, .3) - normal_lccdf(0 | 0, .3); target += std_normal_lpdf(to_vector(biasID_z)); // target += normal_lpdf(to_vector(biasID_z) | 0, 1); target += std_normal_lpdf(to_vector(betaID_z)); // target += normal_lpdf(to_vector(betaID_z) | 0, 1); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial,agent] | biasM + biasID[agent] + logit(memory[trial, agent]) * (betaM + betaID[agent])); } } } generated quantities{ real biasM_prior; real&lt;lower=0&gt; biasSD_prior; real betaM_prior; real&lt;lower=0&gt; betaSD_prior; real bias_prior; real beta_prior; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds2; biasM_prior = normal_rng(0,1); biasSD_prior = normal_lb_rng(0,0.3,0); betaM_prior = normal_rng(0,1); betaSD_prior = normal_lb_rng(0,0.3,0); bias_prior = normal_rng(biasM_prior, biasSD_prior); beta_prior = normal_rng(betaM_prior, betaSD_prior); for (agent in 1:agents){ prior_preds0[agent] = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1[agent] = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2[agent] = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0[agent] = binomial_rng(trials, inv_logit(biasM + biasID[agent] + 0 * (betaM + betaID[agent]))); posterior_preds1[agent] = binomial_rng(trials, inv_logit(biasM + biasID[agent] + 1 * (betaM + betaID[agent]))); posterior_preds2[agent] = binomial_rng(trials, inv_logit(biasM + biasID[agent] + 2 * (betaM + betaID[agent]))); } } &quot; write_stan_file( stan_model_nc, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelMemory_nc.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelMemory_nc.stan&quot;) mod_nc &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod_nc$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/W5_MultilevelMemory_noncentered.RDS&quot;) 6.5.6 Assessing multilevel memory samples &lt;- readRDS(&quot;simmodels/W5_MultilevelMemory_noncentered.RDS&quot;) samples$cmdstan_diagnose() ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory_nc-202303101250-1-612dbb.csv not found ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory_nc-202303101250-2-612dbb.csv not found ## No valid input files, exiting. samples$summary(c(&quot;biasM&quot;, &quot;betaM&quot;, &quot;biasSD&quot;, &quot;betaSD&quot;)) ## # A tibble: 4 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 biasM 0.538 0.537 0.0870 0.0875 0.397 0.683 1.00 1315. 2025. ## 2 betaM 1.02 1.02 0.0726 0.0732 0.901 1.14 1.00 1187. 2168. ## 3 biasSD 0.281 0.281 0.0702 0.0698 0.168 0.401 1.00 630. 956. ## 4 betaSD 0.411 0.409 0.0497 0.0493 0.333 0.499 1.00 1394. 2137. draws_df &lt;- as_draws_df(samples$draws()) p1 &lt;- ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) + geom_line() + theme_classic() p2 &lt;- ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) + geom_line() + theme_classic() p3 &lt;- ggplot(draws_df, aes(.iteration, betaM, group = .chain, color = .chain)) + geom_line() + theme_classic() p4 &lt;- ggplot(draws_df, aes(.iteration, betaSD, group = .chain, color = .chain)) + geom_line() + theme_classic() p1 + p2 + p3 + p4 6.5.6.1 Predictive prior checks ## ggplot(draws_df) + geom_histogram(aes(`prior_preds0[1]`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + geom_histogram(aes(`prior_preds1[1]`), color = &quot;darkblue&quot;, fill = &quot;green&quot;, alpha = 0.3) + geom_histogram(aes(`prior_preds2[1]`), color = &quot;darkblue&quot;, fill = &quot;red&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 6.5.6.2 Prior posterior update checks biasM &lt;- 0 biasSD &lt;- 0.1 betaM &lt;- 1.5 betaSD &lt;- 0.3 ## p1 &lt;- ggplot(draws_df) + geom_density(aes(logit_scaled(biasM)), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(biasM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0) + xlab(&quot;Mean bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p2 &lt;- ggplot(draws_df) + geom_density(aes(biasSD), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(biasSD_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.1) + xlab(&quot;Variance of bias&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p3 &lt;- ggplot(draws_df) + geom_density(aes(betaM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(betaM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 1.5) + xlab(&quot;Mean Beta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p4 &lt;- ggplot(draws_df) + geom_density(aes(betaSD), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(betaSD_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = 0.3) + xlab(&quot;Variance of beta&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p1 + p2 + p3 + p4 6.5.6.3 Posterior predictive checks p1 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds0[1]`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds0[1]`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p2 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds1[1]`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds1[1]`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p3 &lt;- ggplot(draws_df) + geom_histogram(aes(`prior_preds2[1]`), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, alpha = 0.3) + geom_histogram(aes(`posterior_preds2[1]`), color = &quot;darkblue&quot;, fill = &quot;blue&quot;, alpha = 0.3) + xlab(&quot;Predicted right hands out of 120 trials&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() p1 + p2 + p3 ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p1 &lt;- ggplot(draws_df, aes(biasM, biasSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p2 &lt;- ggplot(draws_df, aes(betaM, betaSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p3 &lt;- ggplot(draws_df, aes(biasM, betaM, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p4 &lt;- ggplot(draws_df, aes(biasSD, betaSD, group = .chain, color = .chain)) + geom_point(alpha = 0.1) + theme_classic() p1 + p2 + p3 + p4 ggplot(draws_df) + geom_density(aes(inv_logit_scaled(`biasID[1]`)), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[15]`)), fill = &quot;green&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[21]`)), fill = &quot;lightblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[31]`)), fill = &quot;darkblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[41]`)), fill = &quot;yellow&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[51]`)), fill = &quot;darkgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`biasID[61]`)), fill = &quot;lightgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(biasM_prior)), fill = &quot;pink&quot;, alpha = 0.3) + geom_density(aes(bias_prior), fill = &quot;purple&quot;, alpha = 0.3) + xlab(&quot;Bias parameter&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(inv_logit_scaled(`betaID[1]`)), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[15]`)), fill = &quot;green&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[21]`)), fill = &quot;lightblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[31]`)), fill = &quot;darkblue&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[41]`)), fill = &quot;yellow&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[51]`)), fill = &quot;darkgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(`betaID[61]`)), fill = &quot;lightgreen&quot;, alpha = 0.3) + geom_density(aes(inv_logit_scaled(betaM_prior)), fill = &quot;pink&quot;, alpha = 0.3) + geom_density(aes(beta_prior), fill = &quot;purple&quot;, alpha = 0.3) + xlab(&quot;Beta parameter&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() 6.5.7 Multilevel memory with correlation between parameters stan_model_nc_cor &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (heads and tails) // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { real biasM; real betaM; vector&lt;lower = 0&gt;[2] tau; matrix[2, agents] z_IDs; cholesky_factor_corr[2] L_u; } transformed parameters { array[trials, agents] real memory; matrix[agents,2] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(tau[1] | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(betaM | 0, .3); target += normal_lpdf(tau[2] | 0, .3) - normal_lccdf(0 | 0, .3); target += lkj_corr_cholesky_lpdf(L_u | 2); target += std_normal_lpdf(to_vector(z_IDs)); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial, agent] | biasM + IDs[agent, 1] + memory[trial, agent] * (betaM + IDs[agent, 2])); } } } generated quantities{ real biasM_prior; real&lt;lower=0&gt; biasSD_prior; real betaM_prior; real&lt;lower=0&gt; betaSD_prior; real bias_prior; real beta_prior; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds2; biasM_prior = normal_rng(0,1); biasSD_prior = normal_lb_rng(0,0.3,0); betaM_prior = normal_rng(0,1); betaSD_prior = normal_lb_rng(0,0.3,0); bias_prior = normal_rng(biasM_prior, biasSD_prior); beta_prior = normal_rng(betaM_prior, betaSD_prior); for (i in 1:agents){ prior_preds0[i] = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1[i] = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2[i] = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 0 * (betaM + IDs[i,2]))); posterior_preds1[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 1 * (betaM + IDs[i,2]))); posterior_preds2[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 2 * (betaM + IDs[i,2]))); } } &quot; write_stan_file( stan_model_nc_cor, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelMemory_nc_cor.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelMemory_nc_cor.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/Memory_noncentered_corr.RDS&quot;) 6.5.8 Assessing multilevel memory [MISSING LOTS OF EVALUATION] samples &lt;- readRDS(&quot;simmodels/W5_MultilevelMemory_noncentered_corr.RDS&quot;) samples$cmdstan_diagnose() ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory_nc_cor-202303100657-1-969904.csv not found ## File /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/RtmpTP5vj3/W5_MultilevelMemory_nc_cor-202303100657-2-969904.csv not found ## No valid input files, exiting. 6.5.9 Multilevel memory no pooling [MISSING: EXPLANATION OF NO POOLING] stan_model &lt;- &quot; // The input (data) for the model. n of trials and h of heads data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { array[trials] real bias; array[trials] real beta; } transformed parameters { array[trials, agents] real memory; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(bias | 0, 1); target += normal_lpdf(beta | 0, 1); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial, agent] | bias[agent] + memory[trial, agent] * (beta[agent])); } } } generated quantities{ real bias_prior; real beta_prior; int&lt;lower=0, upper = trials&gt; prior_preds0; int&lt;lower=0, upper = trials&gt; prior_preds1; int&lt;lower=0, upper = trials&gt; prior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds2; bias_prior = normal_rng(0,1); beta_prior = normal_rng(0,1); prior_preds0 = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1 = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2 = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); for (i in 1:agents){ posterior_preds0[i] = binomial_rng(trials, inv_logit(bias[i] + 0 * (beta[i]))); posterior_preds1[i] = binomial_rng(trials, inv_logit(bias[i] + 1 * (beta[i]))); posterior_preds2[i] = binomial_rng(trials, inv_logit(bias[i] + 2 * (beta[i]))); } } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelMemory_nopooling.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelMemory_nopooling.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/W5_MultilevelMemory_nopooling.RDS&quot;) [MISSING: Evaluation of NO POOLING] 6.6 Multilevel full pooling [MISSING: EXPLANATION OF FULL POOLING] stan_model &lt;- &quot; // The input (data) for the model. n of trials and h of heads data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { real bias; real beta; } transformed parameters { array[trials, agents] real memory; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(bias | 0, 1); target += normal_lpdf(beta | 0, 1); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial, agent] | bias + memory[trial, agent] * beta); } } } generated quantities{ real bias_prior; real beta_prior; int&lt;lower=0, upper = trials&gt; prior_preds0; int&lt;lower=0, upper = trials&gt; prior_preds1; int&lt;lower=0, upper = trials&gt; prior_preds2; int&lt;lower=0, upper = trials&gt; posterior_preds0; int&lt;lower=0, upper = trials&gt; posterior_preds1; int&lt;lower=0, upper = trials&gt; posterior_preds2; bias_prior = normal_rng(0,1); beta_prior = normal_rng(0,1); prior_preds0 = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1 = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2 = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0 = binomial_rng(trials, inv_logit(bias + 0 * (beta))); posterior_preds1 = binomial_rng(trials, inv_logit(bias + 1 * (beta))); posterior_preds2 = binomial_rng(trials, inv_logit(bias + 2 * (beta))); } &quot; write_stan_file( stan_model, dir = &quot;stan/&quot;, basename = &quot;W5_MultilevelMemory_fullpooling.stan&quot;) file &lt;- file.path(&quot;stan/W5_MultilevelMemory_fullpooling.stan&quot;) mod &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) # The following command calls Stan with specific options. samples &lt;- mod$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) samples$save_object(file = &quot;simmodels/W5_MultilevelMemory_fullpooling.RDS&quot;) [MISSING: Evaluation of FULL POOLING] [MISSING: PARAMETER RECOVERY IN A MULTILEVEL FRAMEWORK (IND VS POP)] "],["model-comparison.html", "Chapter 7 Model comparison 7.1 Define parameters 7.2 Generating the agents 7.3 Prep the data 7.4 Create the models: random agents 7.5 Multilevel memory model 7.6 Fitting the models to the data 7.7 Implementing Cross-Validation 7.8 Calculating elpd and comparing 7.9 Mixture models 7.10 Stan model mixing biased and noise 7.11 Fitting and assessing the model 7.12 Basic evaluation 7.13 Multilevel mixture model", " Chapter 7 Model comparison [MISSING INTRO] Imagine havi Model comparison defines a broad range of practices aimed at identifying among a set of models the best model for a given data set. What “best” means is, however, a non-trivial question. Ideally, “best” would mean the model describing the mechanism that actually generated the data. However, as we will see that is a tricky proposition and we analysts tend to rely on proxies such as the model that explains the most variance in the (training) data, or - better - the model that best predicts new (test) data. These proxies can be useful, but we should always remember that predictive performance is not a magical solution. It allows us to combat overfitting to the training sample, but it has two key limitations. 1) it might be overfitting to the training population, that is, to the In this chapter, we rely on previously generated data: biased agents playing against the memory agents. This provides us with data generated according to two different mechanisms: biased agents and memory agents. We can fit both models separately on each of the two sets of agents, so we can compare the relative performance of the two models: can we identify the true model generating the data (in a setup where truth is known)? 7.1 Define parameters pacman::p_load(tidyverse, here, posterior, cmdstanr, brms, tidybayes, loo, job) # Shared parameters agents &lt;- 100 trials &lt;- 120 noise &lt;- 0 # Biased agents parameters rateM &lt;- 1.386 # roughly 0.8 once inv_logit scaled rateSD &lt;- 0.65 # roughly giving a sd of 0.1 in prob scale # Memory agents parameters biasM &lt;- 0 biasSD &lt;- 0.1 betaM &lt;- 1.5 betaSD &lt;- 0.3 # Functions of the agents RandomAgentNoise_f &lt;- function(rate, noise) { choice &lt;- rbinom(1, 1, inv_logit_scaled(rate)) if (rbinom(1, 1, noise) == 1) { choice = rbinom(1, 1, 0.5) } return(choice) } MemoryAgentNoise_f &lt;- function(bias, beta, otherRate, noise) { rate &lt;- inv_logit_scaled(bias + beta * logit_scaled(otherRate)) choice &lt;- rbinom(1, 1, rate) if (rbinom(1, 1, noise) == 1) { choice = rbinom(1, 1, 0.5) } return(choice) } 7.2 Generating the agents [MISSING: PARALLELIZE] # Looping through all the agents to generate the data. d &lt;- NULL for (agent in 1:agents) { rate &lt;- rnorm(1, rateM, rateSD) bias &lt;- rnorm(1, biasM, biasSD) beta &lt;- rnorm(1, betaM, betaSD) randomChoice &lt;- rep(NA, trials) memoryChoice &lt;- rep(NA, trials) memoryRate &lt;- rep(NA, trials) for (trial in 1:trials) { randomChoice[trial] &lt;- RandomAgentNoise_f(rate, noise) if (trial == 1) { memoryChoice[trial] &lt;- rbinom(1,1,0.5) } else { memoryChoice[trial] &lt;- MemoryAgentNoise_f(bias, beta, mean(randomChoice[1:trial], na.rm = T), noise) } } temp &lt;- tibble(agent, trial = seq(trials), randomChoice, randomRate = rate, memoryChoice, memoryRate, noise, rateM, rateSD, bias, beta, biasM, biasSD, betaM, betaSD) if (agent &gt; 1) { d &lt;- rbind(d, temp) } else{ d &lt;- temp } } d &lt;- d %&gt;% group_by(agent) %&gt;% mutate( randomRate = cumsum(randomChoice) / seq_along(randomChoice), memoryRate = cumsum(memoryChoice) / seq_along(memoryChoice) ) 7.3 Prep the data d1 &lt;- d %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) d2 &lt;- d %&gt;% subset(select = c(agent, memoryChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = memoryChoice) ## Create the data data_biased &lt;- list( trials = trials, agents = agents, h = as.matrix(d1[,2:101]), other = as.matrix(d2[,2:101]) ) data_memory &lt;- list( trials = trials, agents = agents, h = as.matrix(d2[,2:101]), other = as.matrix(d1[,2:101]) ) 7.4 Create the models: random agents N.B. compared to before we also need to include a log-likelihood, to calculate loo for model comparison. stan_biased_model &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (right and left). Now multilevel // functions{ real normal_lb_rng(real mu, real sigma, real lb) { // normal distribution with a lower bound real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. n of trials and h of hands data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; } // The parameters accepted by the model. parameters { real thetaM; real&lt;lower = 0&gt; thetaSD; array[agents] real theta; } // The model to be estimated. model { target += normal_lpdf(thetaM | 0, 1); target += normal_lpdf(thetaSD | 0, .3) - normal_lccdf(0 | 0, .3); // The prior for theta is a uniform distribution between 0 and 1 target += normal_lpdf(theta | thetaM, thetaSD); for (i in 1:agents) target += bernoulli_logit_lpmf(h[,i] | theta[i]); } generated quantities{ real thetaM_prior; real&lt;lower=0&gt; thetaSD_prior; real&lt;lower=0, upper=1&gt; theta_prior; real&lt;lower=0, upper=1&gt; theta_posterior; int&lt;lower=0, upper = trials&gt; prior_preds; int&lt;lower=0, upper = trials&gt; posterior_preds; array[trials, agents] real log_lik; thetaM_prior = normal_rng(0,1); thetaSD_prior = normal_lb_rng(0,0.3,0); theta_prior = inv_logit(normal_rng(thetaM_prior, thetaSD_prior)); theta_posterior = inv_logit(normal_rng(thetaM, thetaSD)); prior_preds = binomial_rng(trials, inv_logit(thetaM_prior)); posterior_preds = binomial_rng(trials, inv_logit(thetaM)); for (i in 1:agents){ for (t in 1:trials){ log_lik[t,i] = bernoulli_logit_lpmf(h[t,i] | theta[i]); } } } &quot; write_stan_file( stan_biased_model, dir = &quot;stan/&quot;, basename = &quot;W6_MultilevelBias.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MultilevelBias.stan&quot; file &lt;- file.path(&quot;stan/W6_MultilevelBias.stan&quot;) mod_biased &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 7.5 Multilevel memory model stan_memory_model &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (heads and tails) // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; } // The parameters accepted by the model. parameters { real biasM; real betaM; vector&lt;lower = 0&gt;[2] tau; matrix[2, agents] z_IDs; cholesky_factor_corr[2] L_u; } transformed parameters { array[trials, agents] real memory; matrix[agents,2] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(tau[1] | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(betaM | 0, .3); target += normal_lpdf(tau[2] | 0, .3) - normal_lccdf(0 | 0, .3); target += lkj_corr_cholesky_lpdf(L_u | 2); target += std_normal_lpdf(to_vector(z_IDs)); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial, agent] | biasM + IDs[agent, 1] + memory[trial, agent] * (betaM + IDs[agent, 2])); } } } generated quantities{ real biasM_prior; real&lt;lower=0&gt; biasSD_prior; real betaM_prior; real&lt;lower=0&gt; betaSD_prior; real bias_prior; real beta_prior; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds2; array[trials, agents] real log_lik; biasM_prior = normal_rng(0,1); biasSD_prior = normal_lb_rng(0,0.3,0); betaM_prior = normal_rng(0,1); betaSD_prior = normal_lb_rng(0,0.3,0); bias_prior = normal_rng(biasM_prior, biasSD_prior); beta_prior = normal_rng(betaM_prior, betaSD_prior); for (i in 1:agents){ prior_preds0[i] = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1[i] = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2[i] = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 0 * (betaM + IDs[i,2]))); posterior_preds1[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 1 * (betaM + IDs[i,2]))); posterior_preds2[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 2 * (betaM + IDs[i,2]))); for (t in 1:trials){ log_lik[t,i] = bernoulli_logit_lpmf(h[t, i] | biasM + IDs[i, 1] + memory[t, i] * (betaM + IDs[i, 2])); } } } &quot; write_stan_file( stan_memory_model, dir = &quot;stan/&quot;, basename = &quot;W6_MultilevelMemory.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MultilevelMemory.stan&quot; file &lt;- file.path(&quot;stan/W6_MultilevelMemory.stan&quot;) mod_memory &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 7.6 Fitting the models to the data # Fitting biased agent model to biased agent data fit_biased2biased &lt;- mod_biased$sample( data = data_biased, seed = 123, chains = 1, parallel_chains = 1, threads_per_chain = 4, iter_warmup = 2000, iter_sampling = 2000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99, ) save(fit_biased2biased, data_biased, file = &quot;simmodels/W6_fit_biased2biased.RData&quot;) fit_biased2biased$save_object(file = &quot;simmodels/W6_fit_biased2biased.RDS&quot;) fit_biased2biased$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W6_fit_biased2biased&quot;) # Fitting biased agent model to memory agent data fit_biased2memory &lt;- mod_biased$sample( data = data_memory, seed = 123, chains = 1, parallel_chains = 1, threads_per_chain = 4, iter_warmup = 2000, iter_sampling = 2000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99, ) save(fit_biased2memory, data_memory, file = &quot;simmodels/W6_fit_biased2memory.RData&quot;) fit_biased2memory$save_object(file = &quot;simmodels/W6_fit_biased2memory.RDS&quot;) fit_biased2memory$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W6_fit_biased2memory&quot;) fit_memory2biased &lt;- mod_memory$sample( data = data_biased, seed = 123, chains = 1, parallel_chains = 1, threads_per_chain = 4, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) save(fit_memory2biased, data_biased, file = &quot;simmodels/W6_fit_memory2biased.RData&quot;) fit_memory2biased$save_object(file = &quot;simmodels/W6_fit_memory2biased.RDS&quot;) fit_memory2biased$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W6_fit_memory2biased&quot;) fit_memory2memory &lt;- mod_memory$sample( data = data_memory, seed = 123, chains = 1, parallel_chains = 1, threads_per_chain = 4, iter_warmup = 2000, iter_sampling = 2000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99, ) save(fit_memory2memory, data_memory, file = &quot;simmodels/W6_fit_memory2memory.RData&quot;) fit_memory2memory$save_object(file = &quot;simmodels/W6_fit_memory2memory.RDS&quot;) fit_memory2memory$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W6_fit_memory2memory&quot;) fit_biased2biased &lt;- as_cmdstan_fit(&quot;simmodels/W6_fit_biased2biased-202303141000-1-75c13f.csv&quot;) Loo_biased2biased &lt;- fit_biased2biased$loo(save_psis = TRUE, cores = 4) p1 &lt;- plot(Loo_biased2biased) p1 &lt;- p1 + ylim(-0.4, 0.4) fit_biased2memory &lt;- as_cmdstan_fit(&quot;simmodels/W6_fit_biased2memory-202303141001-1-513269.csv&quot;) Loo_biased2memory &lt;- fit_biased2memory$loo(save_psis = TRUE, cores = 4) plot(Loo_biased2memory) fit_memory2biased &lt;- as_cmdstan_fit(&quot;simmodels/W6_fit_memory2biased-202303141022-1-778c49.csv&quot;) Loo_memory2biased &lt;- fit_memory2biased$loo(save_psis = TRUE, cores = 4) plot(Loo_memory2biased) fit_memory2memory &lt;- as_cmdstan_fit(&quot;simmodels/W6_fit_memory2memory-202303141150-1-35a401.csv&quot;) Loo_memory2memory &lt;- fit_memory2memory$loo(save_psis = TRUE, cores = 4) plot(Loo_memory2memory) elpd &lt;- tibble( n = seq(12000), biased_diff_elpd = Loo_biased2biased$pointwise[, &quot;elpd_loo&quot;] - Loo_memory2biased$pointwise[, &quot;elpd_loo&quot;], memory_diff_elpd = Loo_memory2memory$pointwise[, &quot;elpd_loo&quot;] - Loo_biased2memory$pointwise[, &quot;elpd_loo&quot;]) p1 &lt;- ggplot(elpd, aes(x = n, y = biased_diff_elpd)) + geom_point(alpha = .1) + #xlim(.5,1.01) + #ylim(-1.5,1.5) + geom_hline(yintercept = 0, color = &quot;red&quot;, linetype = &quot;dashed&quot;) + theme_bw() p2 &lt;- ggplot(elpd, aes(x = n, y = memory_diff_elpd)) + geom_point(alpha = .1) + #xlim(.5,1.01) + #ylim(-1.5,1.5) + geom_hline(yintercept = 0, color = &quot;red&quot;, linetype = &quot;dashed&quot;) + theme_bw() library(patchwork) p1 + p2 loo_compare(Loo_biased2biased, Loo_memory2biased) ## elpd_diff se_diff ## model1 0.0 0.0 ## model2 -2.7 0.5 loo_compare(Loo_biased2memory, Loo_memory2memory) ## elpd_diff se_diff ## model2 0.0 0.0 ## model1 -115.9 11.5 loo_model_weights(list(Loo_biased2biased, Loo_memory2biased)) ## Method: stacking ## ------ ## weight ## model1 1.000 ## model2 0.000 loo_model_weights(list(Loo_biased2memory, Loo_memory2memory)) ## Method: stacking ## ------ ## weight ## model1 0.000 ## model2 1.000 7.7 Implementing Cross-Validation [MISSING: STAN CODE WITH THE TEST] [MISSING: VERSION W TRANSFORMED DATA] 7.7.1 Create cross-validation ready stan model for biased agents N.B. compared to before we also need to include specifics for test data stan_biased_cv_model &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (right and left). Now multilevel // functions{ real normal_lb_rng(real mu, real sigma, real lb) { // normal distribution with a lower bound real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. n of trials and h of hands data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; int&lt;lower = 1&gt; agents_test; array[trials, agents_test] int h_test; } // The parameters accepted by the model. parameters { real thetaM; real&lt;lower = 0&gt; thetaSD; array[agents] real theta; } // The model to be estimated. model { target += normal_lpdf(thetaM | 0, 1); target += normal_lpdf(thetaSD | 0, .3) - normal_lccdf(0 | 0, .3); // The prior for theta is a uniform distribution between 0 and 1 target += normal_lpdf(theta | thetaM, thetaSD); for (i in 1:agents) target += bernoulli_logit_lpmf(h[,i] | theta[i]); } generated quantities{ real thetaM_prior; real&lt;lower=0&gt; thetaSD_prior; real&lt;lower=0, upper=1&gt; theta_prior; real&lt;lower=0, upper=1&gt; theta_posterior; int&lt;lower=0, upper = trials&gt; prior_preds; int&lt;lower=0, upper = trials&gt; posterior_preds; array[trials, agents] real log_lik; array[trials, agents_test] real log_lik_test; thetaM_prior = normal_rng(0,1); thetaSD_prior = normal_lb_rng(0,0.3,0); theta_prior = inv_logit(normal_rng(thetaM_prior, thetaSD_prior)); theta_posterior = inv_logit(normal_rng(thetaM, thetaSD)); prior_preds = binomial_rng(trials, inv_logit(thetaM_prior)); posterior_preds = binomial_rng(trials, inv_logit(thetaM)); for (i in 1:agents){ for (t in 1:trials){ log_lik[t,i] = bernoulli_logit_lpmf(h[t,i] | theta[i]); } } for (i in 1:agents_test){ for (t in 1:trials){ log_lik_test[t,i] = bernoulli_lpmf(h_test[t,i] | theta_posterior); } } } &quot; write_stan_file( stan_biased_cv_model, dir = &quot;stan/&quot;, basename = &quot;W6_MultilevelBias_cv.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MultilevelBias_cv.stan&quot; file &lt;- file.path(&quot;stan/W6_MultilevelBias_cv.stan&quot;) mod_biased_cv &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 7.7.2 Create cross-validation ready stan model for memory agents stan_memory_cv_model &lt;- &quot; // // This STAN model infers a random bias from a sequences of 1s and 0s (heads and tails) // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] int other; int&lt;lower = 1&gt; agents_test; array[trials, agents_test] int h_test; array[trials, agents_test] int other_test; } // The parameters accepted by the model. parameters { real biasM; real betaM; vector&lt;lower = 0&gt;[2] tau; matrix[2, agents] z_IDs; cholesky_factor_corr[2] L_u; } transformed parameters { array[trials, agents] real memory; array[trials, agents_test] real memory_test; matrix[agents,2] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; for (agent in 1:agents){ for (trial in 1:trials){ if (trial == 1) { memory[trial, agent] = 0.5; } if (trial &lt; trials){ memory[trial + 1, agent] = memory[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory[trial + 1, agent] == 0){memory[trial + 1, agent] = 0.01;} if (memory[trial + 1, agent] == 1){memory[trial + 1, agent] = 0.99;} } } } for (agent in 1:agents_test){ for (trial in 1:trials){ if (trial == 1) { memory_test[trial, agent] = 0.5; } if (trial &lt; trials){ memory_test[trial + 1, agent] = memory_test[trial, agent] + ((other[trial, agent] - memory[trial, agent]) / trial); if (memory_test[trial + 1, agent] == 0){memory_test[trial + 1, agent] = 0.01;} if (memory_test[trial + 1, agent] == 1){memory_test[trial + 1, agent] = 0.99;} } } } } // The model to be estimated. model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(tau[1] | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(betaM | 0, .3); target += normal_lpdf(tau[2] | 0, .3) - normal_lccdf(0 | 0, .3); target += lkj_corr_cholesky_lpdf(L_u | 2); target += std_normal_lpdf(to_vector(z_IDs)); for (agent in 1:agents){ for (trial in 1:trials){ target += bernoulli_logit_lpmf(h[trial, agent] | biasM + IDs[agent, 1] + memory[trial, agent] * (betaM + IDs[agent, 2])); } } } generated quantities{ real biasM_prior; real&lt;lower=0&gt; biasSD_prior; real betaM_prior; real&lt;lower=0&gt; betaSD_prior; real bias_prior; real beta_prior; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; prior_preds2; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds0; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds1; array[agents] int&lt;lower=0, upper = trials&gt; posterior_preds2; array[trials, agents] real log_lik; array[trials, agents_test] real log_lik_test; biasM_prior = normal_rng(0,1); biasSD_prior = normal_lb_rng(0,0.3,0); betaM_prior = normal_rng(0,1); betaSD_prior = normal_lb_rng(0,0.3,0); bias_prior = normal_rng(biasM_prior, biasSD_prior); beta_prior = normal_rng(betaM_prior, betaSD_prior); for (i in 1:agents){ prior_preds0[i] = binomial_rng(trials, inv_logit(bias_prior + 0 * beta_prior)); prior_preds1[i] = binomial_rng(trials, inv_logit(bias_prior + 1 * beta_prior)); prior_preds2[i] = binomial_rng(trials, inv_logit(bias_prior + 2 * beta_prior)); posterior_preds0[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 0 * (betaM + IDs[i,2]))); posterior_preds1[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 1 * (betaM + IDs[i,2]))); posterior_preds2[i] = binomial_rng(trials, inv_logit(biasM + IDs[i,1] + 2 * (betaM + IDs[i,2]))); for (t in 1:trials){ log_lik[t,i] = bernoulli_logit_lpmf(h[t, i] | biasM + IDs[i, 1] + memory[t, i] * (betaM + IDs[i, 2])); } } for (i in 1:agents_test){ for (t in 1:trials){ log_lik_test[t,i] = bernoulli_logit_lpmf(h_test[t,i] | biasM + memory_test[t, i] * betaM); } } } &quot; write_stan_file( stan_memory_cv_model, dir = &quot;stan/&quot;, basename = &quot;W6_MultilevelMemory_cv.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MultilevelMemory_cv.stan&quot; file &lt;- file.path(&quot;stan/W6_MultilevelMemory_cv.stan&quot;) mod_memory_cv &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! [MISSING: PARALLELIZE] d$fold &lt;- kfold_split_grouped(K = 10, x = d$agent) log_pd_biased_kfold &lt;- matrix(nrow = 1000, ncol = 12000) log_pd_memory_kfold &lt;- matrix(nrow = 1000, ncol = 12000) for (k in unique(d$fold)) { # Training set for k d_train &lt;- d %&gt;% filter(fold != k) ## Create the data d_memory1_train &lt;- d_train %&gt;% subset(select = c(agent, memoryChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = memoryChoice) d_memory2_train &lt;- d_train %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) agents_n &lt;- length(unique(d_train$agent)) d_test &lt;- d %&gt;% filter(fold == k) d_memory1_test &lt;- d_test %&gt;% subset(select = c(agent, memoryChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = memoryChoice) d_memory2_test &lt;- d_test %&gt;% subset(select = c(agent, randomChoice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = randomChoice) agents_test_n &lt;- length(unique(d_test$agent)) data_memory &lt;- list( trials = trials, agents = agents_n, agents_test = agents_test_n, h = as.matrix(d_memory1_train[,2:(agents_n + 1)]), other = as.matrix(d_memory2_train[,2:(agents_n + 1)]), h_test = as.matrix(d_memory1_test[,2:(agents_test_n + 1)]), other_test = as.matrix(d_memory2_test[,2:(agents_test_n + 1)])) # Train the models fit_random &lt;- mod_biased_cv$sample( data = data_memory, seed = 123, chains = 1, threads_per_chain = 4, iter_warmup = 1000, iter_sampling = 1000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99 ) fit_memory &lt;- mod_memory_cv$sample( data = data_memory, seed = 123, chains = 1, threads_per_chain = 4, iter_warmup = 1000, iter_sampling = 1000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99 ) # Extract log likelihood which represents # the pointwise predictive density. # n.b. the matrix has 1000 row, and 12000 columns. # d$fold==k yields 12000 logical values, of which 1200 TRUEs, identifying 1200 columns ## the fit blabla yields 1000 obs (samples) and 1190 variables instead of 1200 log_pd_biased_kfold[, d$fold == k] &lt;- fit_random$draws(&quot;log_lik_test&quot;, format = &quot;matrix&quot;) log_pd_memory_kfold[, d$fold == k] &lt;- fit_memory$draws(&quot;log_lik_test&quot;, format = &quot;matrix&quot;) } save(log_pd_biased_kfold, log_pd_memory_kfold, file = &quot;simmodels/W6_CV_Biased&amp;Memory.RData&quot;) 7.8 Calculating elpd and comparing load(&quot;simmodels/W6_CV_Biased&amp;Memory.RData&quot;) elpd_biased_kfold &lt;- elpd(log_pd_biased_kfold) elpd_memory_kfold &lt;- elpd(log_pd_memory_kfold) loo_compare(elpd_biased_kfold, elpd_memory_kfold) ## elpd_diff se_diff ## model1 0.0 0.0 ## model2 -437.3 23.9 #loo_model_weights(elpd_biased_kfold, elpd_memory_kfold) 7.9 Mixture models 7.9.1 Load the dataset We load the data set from chapter NN, where we loop through possible rates and noise levels, and pick one agent to build up the model progressively. d &lt;- read_csv(&quot;simdata/W3_randomnoise.csv&quot;) ## Rows: 7920 Columns: 5 ## ── Column specification ───────────────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (5): trial, choice, rate, noise, cumulativerate ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. dd &lt;- d %&gt;% subset(rate == 0.8 &amp; noise == 0.1) data &lt;- list( n = 120, h = dd$choice ) 7.10 Stan model mixing biased and noise We then build a Stan model with the noise parameter stan_mixture_model &lt;- &quot; // This Stan model defines a mixture of bernoulli (random bias + noise) // // The input (data) for the model. n of trials and h of heads data { int&lt;lower=1&gt; n; array[n] int h; } // The parameters accepted by the model. parameters { real bias; real noise; } // The model to be estimated. model { // The prior for theta is a uniform distribution between 0 and 1 target += normal_lpdf(bias | 0, 1); target += normal_lpdf(noise | 0, 1); // The model consists of a binomial distributions with a rate theta target += log_sum_exp(log(inv_logit(noise)) + bernoulli_logit_lpmf(h | 0), log1m(inv_logit(noise)) + bernoulli_logit_lpmf(h | bias)); } generated quantities{ real&lt;lower=0, upper=1&gt; noise_p; real&lt;lower=0, upper=1&gt; bias_p; noise_p = inv_logit(noise); bias_p = inv_logit(bias); } &quot; write_stan_file( stan_mixture_model, dir = &quot;stan/&quot;, basename = &quot;W6_MixtureSingle.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MixtureSingle.stan&quot; file &lt;- file.path(&quot;stan/W6_MixtureSingle.stan&quot;) mod_mixture &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 7.11 Fitting and assessing the model samples &lt;- mod_mixture$sample( data = data, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4000 [ 12%] (Warmup) ## Chain 1 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 1 Iteration: 1500 / 4000 [ 37%] (Warmup) ## Chain 1 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 1 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 1 Iteration: 2500 / 4000 [ 62%] (Sampling) ## Chain 2 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 2 Iteration: 500 / 4000 [ 12%] (Warmup) ## Chain 2 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 2 Iteration: 1500 / 4000 [ 37%] (Warmup) ## Chain 2 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 2 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 2 Iteration: 2500 / 4000 [ 62%] (Sampling) ## Chain 1 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 1 Iteration: 3500 / 4000 [ 87%] (Sampling) ## Chain 1 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 2 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 2 Iteration: 3500 / 4000 [ 87%] (Sampling) ## Chain 2 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 1 finished in 0.1 seconds. ## Chain 2 finished in 0.2 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 0.1 seconds. ## Total execution time: 0.2 seconds. save(samples, data, file = &quot;simmodels/W7_singlemixture.RData&quot;) samples$save_object(file = &quot;simmodels/W7_singlemixture.RDS&quot;) samples$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W7_singlemixture&quot;) ## Moved 2 files and set internal paths to new locations: ## - /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W7_singlemixture-202303240929-1-372a0a.csv ## - /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W7_singlemixture-202303240929-2-372a0a.csv [MISSING: EVALUATION] 7.12 Basic evaluation samples$summary() ## # A tibble: 5 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -68.2 -67.9 0.979 0.738 -70.1 -67.2 1.00 1466. 2065. ## 2 bias 1.19 1.19 0.211 0.213 0.856 1.54 1.00 2476. 2117. ## 3 noise -0.400 -0.392 0.917 0.903 -1.93 1.10 1.00 2688. 2213. ## 4 noise_p 0.416 0.403 0.191 0.208 0.126 0.750 1.00 2688. 2213. ## 5 bias_p 0.765 0.766 0.0376 0.0381 0.702 0.824 1.00 2476. 2117. 7.13 Multilevel mixture model ### Multilevel mixture stan_multilevelMixture_model &lt;- &quot; // // This Stan model defines a mixture of bernoulli (random bias + noise) // functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. n of trials and h of heads data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; } // The parameters accepted by the model. parameters { real thetaM; real noiseM; // p of noise vector&lt;lower = 0&gt;[2] tau; matrix[2, agents] z_IDs; cholesky_factor_corr[2] L_u; } transformed parameters { matrix[agents,2] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; } // The model to be estimated. model { target += normal_lpdf(thetaM | 0, 1); target += normal_lpdf(tau[1] | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(noiseM | -1, .5); target += normal_lpdf(tau[2] | 0, .3) - normal_lccdf(0 | 0, .3); target += lkj_corr_cholesky_lpdf(L_u | 2); target += std_normal_lpdf(to_vector(z_IDs)); for (i in 1:agents) target += log_sum_exp( log(inv_logit(noiseM + IDs[i,2])) + // p of noise bernoulli_logit_lpmf(h[,i] | 0), // times post likelihood of the noise model log1m(inv_logit(noiseM + IDs[i,2])) + // 1 - p of noise bernoulli_logit_lpmf(h[,i] | thetaM + IDs[i,1])); // times post likelihood of the bias model } generated quantities{ real thetaM_prior; real&lt;lower=0&gt; thetaSD_prior; real noiseM_prior; real&lt;lower=0&gt; noiseSD_prior; real&lt;lower=0, upper=1&gt; theta_prior; real&lt;lower=0, upper=1&gt; noise_prior; real&lt;lower=0, upper=1&gt; theta_posterior; real&lt;lower=0, upper=1&gt; noise_posterior; array[trials,agents] int&lt;lower=0, upper = trials&gt; prior_noise; array[trials,agents] int&lt;lower=0, upper = trials&gt; posterior_noise; array[trials,agents] int&lt;lower=0, upper = trials&gt; prior_preds; array[trials,agents] int&lt;lower=0, upper = trials&gt; posterior_preds; array[trials, agents] real log_lik; thetaM_prior = normal_rng(0,1); thetaSD_prior = normal_lb_rng(0,0.3,0); theta_prior = inv_logit(normal_rng(thetaM_prior, thetaSD_prior)); noiseM_prior = normal_rng(-1,.5); noiseSD_prior = normal_lb_rng(0,0.3,0); noise_prior = inv_logit(normal_rng(noiseM_prior, noiseSD_prior)); theta_posterior = inv_logit(normal_rng(thetaM, tau[1])); noise_posterior = inv_logit(normal_rng(noiseM, tau[2])); for (i in 1:agents){ for (t in 1:trials){ prior_noise[t,i] = bernoulli_rng(noise_prior); posterior_noise[t,i] = bernoulli_rng(inv_logit(noiseM + IDs[i,2])); if(prior_noise[t,i]==1){ prior_preds[t,i] = bernoulli_rng(theta_prior); } else{ prior_preds[t,i] = bernoulli_rng(0.5); } if(posterior_noise[t,i]==1){ posterior_preds[t,i] = bernoulli_rng(inv_logit(thetaM + IDs[i,1])); } else{ posterior_preds[t,i] = bernoulli_rng(0.5); } log_lik[t,i] = log_sum_exp( log(inv_logit(noiseM + IDs[i,2])) + // p of noise bernoulli_logit_lpmf(h[t,i] | 0), // times post likelihood of the noise model log1m(inv_logit(noiseM + IDs[i,2])) + // 1 - p of noise bernoulli_logit_lpmf(h[t,i] | thetaM + IDs[i,1])); // times post likelihood of the bias model } } } &quot; write_stan_file( stan_multilevelMixture_model, dir = &quot;stan/&quot;, basename = &quot;W6_MixtureMultilevel.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W6_MixtureMultilevel.stan&quot; file &lt;- file.path(&quot;stan/W6_MixtureMultilevel.stan&quot;) mod_mixture &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! samples &lt;- mod_mixture$sample( data = data_biased, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 500, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4000 [ 12%] (Warmup) ## Chain 2 Iteration: 500 / 4000 [ 12%] (Warmup) ## Chain 1 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 2 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 1 Iteration: 1500 / 4000 [ 37%] (Warmup) ## Chain 2 Iteration: 1500 / 4000 [ 37%] (Warmup) ## Chain 1 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 1 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 2 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 2 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 1 Iteration: 2500 / 4000 [ 62%] (Sampling) ## Chain 2 Iteration: 2500 / 4000 [ 62%] (Sampling) ## Chain 1 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 2 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 1 Iteration: 3500 / 4000 [ 87%] (Sampling) ## Chain 2 Iteration: 3500 / 4000 [ 87%] (Sampling) ## Chain 1 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 1 finished in 124.9 seconds. ## Chain 2 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 2 finished in 129.0 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 126.9 seconds. ## Total execution time: 129.1 seconds. save(samples, data, file = &quot;simmodels/W7_multimixture.RData&quot;) samples$save_object(file = &quot;simmodels/W7_multimixture.RDS&quot;) samples$save_output_files(dir = &quot;simmodels&quot;, basename = &quot;W7_multimixture&quot;) ## Moved 2 files and set internal paths to new locations: ## - /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W7_multimixture-202303240933-1-62416b.csv ## - /Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/simmodels/W7_multimixture-202303240933-2-62416b.csv [MISSING: EVALUATION] samples$summary() ## # A tibble: 60,417 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -6413. -6412. 12.9 12.9 -6435. -6392. 1.00 617. 1593. ## 2 thetaM 1.31 1.31 0.0657 0.0650 1.20 1.42 1.00 959. 1657. ## 3 noiseM -2.53 -2.52 0.320 0.318 -3.08 -2.02 1.00 3693. 2620. ## 4 tau[1] 0.599 0.599 0.0501 0.0504 0.521 0.685 1.00 648. 1444. ## 5 tau[2] 0.201 0.171 0.152 0.149 0.0160 0.491 1.00 2949. 2471. ## 6 z_IDs[1,1] -0.301 -0.314 0.352 0.348 -0.862 0.293 1.00 6135. 2887. ## 7 z_IDs[2,1] -0.00973 0.0182 1.01 0.987 -1.69 1.62 1.00 10330. 3009. ## 8 z_IDs[1,2] 0.720 0.713 0.404 0.404 0.0791 1.38 1.00 5924. 2728. ## 9 z_IDs[2,2] -0.00433 0.00141 0.994 1.02 -1.62 1.65 1.00 9280. 2919. ## 10 z_IDs[1,3] -1.22 -1.43 0.820 0.429 -2.05 0.725 1.00 1725. 2060. ## # … with 60,407 more rows samples$loo() ## Warning: Some Pareto k diagnostic values are slightly high. See help(&#39;pareto-k-diagnostic&#39;) for details. ## ## Computed from 4000 by 12000 log-likelihood matrix ## ## Estimate SE ## elpd_loo -6223.1 52.4 ## p_loo 115.1 2.6 ## looic 12446.1 104.8 ## ------ ## Monte Carlo SE of elpd_loo is 0.6. ## ## Pareto k diagnostic values: ## Count Pct. Min. n_eff ## (-Inf, 0.5] (good) 11683 97.4% 86 ## (0.5, 0.7] (ok) 317 2.6% 898 ## (0.7, 1] (bad) 0 0.0% &lt;NA&gt; ## (1, Inf) (very bad) 0 0.0% &lt;NA&gt; ## ## All Pareto k estimates are ok (k &lt; 0.7). ## See help(&#39;pareto-k-diagnostic&#39;) for details. [MISSING: PARAMETER RECOVERY] [MISSING: BIASED VS. MEMORY?] "],["bonus-chapter-win-stay-lose-shift.html", "Chapter 8 Bonus chapter: Win-Stay-Lose-Shift 8.1 Load packages 8.2 Generate data 8.3 Sanity check for the data 8.4 More sanity check 8.5 Create data for single agent model 8.6 Create the model 8.7 Basic assessment 8.8 Create multilevel data 8.9 Create the model 8.10 Quality checks", " Chapter 8 Bonus chapter: Win-Stay-Lose-Shift [MISSING: INTRO] 8.1 Load packages pacman::p_load(tidyverse, here, posterior, cmdstanr, brms, tidybayes, loo) 8.2 Generate data [MISSING: EXPLAIN THE MODEL STEP BY STEP] [MISSING: PARALLELIZE AND MAKE IT MORE SIMILAR TO PREVIOUS DATASETS] 8.3 Sanity check for the data d &lt;- d %&gt;% group_by(agent, strategy) %&gt;% mutate( nextChoice = lead(choice), prevWin = lag(win), prevLose = lag(lose), cumulativerate = cumsum(choice) / seq_along(choice), performance = cumsum(feedback) / seq_along(feedback) ) %&gt;% subset(complete.cases(d)) %&gt;% subset(trial &gt; 1) p1 &lt;- ggplot(d, aes(trial, cumulativerate, group = agent, color = agent)) + geom_line() + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + theme_classic() + facet_wrap(.~strategy) p1 p2a &lt;- ggplot(subset(d, strategy == &quot;Random&quot;), aes(trial, 1 - performance, group = agent, color = agent)) + geom_line() + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + theme_classic() p2b &lt;- ggplot(subset(d, strategy == &quot;WSLS&quot;), aes(trial, performance, group = agent, color = agent)) + geom_line() + geom_hline(yintercept = 0.5, linetype = &quot;dashed&quot;) + ylim(0,1) + theme_classic() library(patchwork) p2a + p2b 8.4 More sanity check ## Checking lose/win are orthogonal ggplot(d, aes(win, lose)) + geom_point() + theme_bw() ## Checking lose/win do determine choice d %&gt;% subset(strategy == &quot;WSLS&quot;) %&gt;% mutate(nextChoice = lead(choice)) %&gt;% group_by(agent, win, lose) %&gt;% summarize(heads = mean(nextChoice)) %&gt;% ggplot(aes(win, heads)) + geom_point() + theme_bw() + facet_wrap(~lose) ## `summarise()` has grouped output by &#39;agent&#39;, &#39;win&#39;. You can override using the `.groups` argument. ## Warning: Removed 100 rows containing missing values (`geom_point()`). 8.5 Create data for single agent model d_a &lt;- d %&gt;% subset( strategy == &quot;WSLS&quot; &amp; agent == 2 ) data_wsls_simple &lt;- list( trials = trials - 1, h = d_a$choice, win = d_a$prevWin, lose = d_a$prevLose ) 8.6 Create the model [MISSING: MORE MEANINGFUL PREDICTIONS, BASED ON THE 4 SCENARIOS] stan_wsls_model &lt;- &quot; functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } data { int&lt;lower = 1&gt; trials; array[trials] int h; vector[trials] win; vector[trials] lose; } parameters { real alpha; real winB; real loseB; } model { target += normal_lpdf(alpha | 0, .3); target += normal_lpdf(winB | 1, 1); target += normal_lpdf(loseB | 1, 1); target += bernoulli_logit_lpmf(h | alpha + winB * win + loseB * lose); } generated quantities{ real alpha_prior; real winB_prior; real loseB_prior; array[trials] int prior_preds; array[trials] int posterior_preds; vector[trials] log_lik; alpha_prior = normal_rng(0, 1); winB_prior = normal_rng(0, 1); loseB_prior = normal_rng(0, 1); prior_preds = bernoulli_rng(inv_logit(winB_prior * win + loseB_prior * lose)); posterior_preds = bernoulli_rng(inv_logit(winB * win + loseB * lose)); for (t in 1:trials){ log_lik[t] = bernoulli_logit_lpmf(h[t] | winB * win + loseB * lose); } } &quot; write_stan_file( stan_wsls_model, dir = &quot;stan/&quot;, basename = &quot;W8_WSLS.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W8_WSLS.stan&quot; file &lt;- file.path(&quot;stan/W8_WSLS.stan&quot;) mod_wsls_simple &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;), pedantic = TRUE) ## Model executable is up to date! samples_wsls_simple &lt;- mod_wsls_simple$sample( data = data_wsls_simple, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 1 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 2 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 2 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 1 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 1 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 2 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 2 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 1 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 2 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 1 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 2 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 1 finished in 0.6 seconds. ## Chain 2 finished in 0.6 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 0.6 seconds. ## Total execution time: 0.7 seconds. 8.7 Basic assessment samples_wsls_simple$summary() ## # A tibble: 364 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -64.9 -64.6 1.24 1.04 -67.4 -63.6 1.00 1358. 2144. ## 2 alpha -0.263 -0.263 0.229 0.223 -0.647 0.108 1.00 1678. 1674. ## 3 winB 1.42 1.41 0.320 0.325 0.899 1.97 1.00 1619. 2074. ## 4 loseB 1.52 1.50 0.374 0.373 0.935 2.15 1.00 2031. 2127. ## 5 alpha_prior -0.0132 -0.0170 1.01 1.02 -1.69 1.64 1.00 3854. 3853. ## 6 winB_prior 0.00992 0.0182 1.00 1.02 -1.62 1.64 1.00 3719. 3813. ## 7 loseB_prior 0.00932 -0.00401 1.00 0.992 -1.60 1.70 1.00 4029. 3767. ## 8 prior_preds[1] 0.487 0 0.500 0 0 1 1.00 4004. NA ## 9 prior_preds[2] 0.501 1 0.500 0 0 1 1.00 3903. NA ## 10 prior_preds[3] 0.492 0 0.500 0 0 1 1.00 3442. NA ## # … with 354 more rows # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples_wsls_simple$draws()) # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(alpha), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(alpha_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d_a$alpha[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(winB), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(winB_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d_a$betaWin[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(loseB), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(loseB_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d_a$betaLose[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() [MISSING: FULL PARAMETER RECOVERY] 8.8 Create multilevel data ## Now multilevel model d_wsls1 &lt;- d %&gt;% subset(strategy == &quot;WSLS&quot;) %&gt;% subset(select = c(agent, choice)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = choice) d_wsls2 &lt;- d %&gt;% subset(strategy == &quot;WSLS&quot;) %&gt;% subset(select = c(agent, prevWin)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = prevWin) d_wsls3 &lt;- d %&gt;% subset(strategy == &quot;WSLS&quot;) %&gt;% subset(select = c(agent, prevLose)) %&gt;% mutate(row = row_number()) %&gt;% pivot_wider(names_from = agent, values_from = prevLose) ## Create the data data_wsls &lt;- list( trials = trials - 1, agents = agents, h = as.matrix(d_wsls1[,2:(agents + 1)]), win = as.matrix(d_wsls2[,2:(agents + 1)]), lose = as.matrix(d_wsls3[,2:(agents + 1)]) ) 8.9 Create the model [MISSING: ADD BIAS] [MISSING: BETTER PREDICTIONS BASED ON 4 SCENARIOS] stan_wsls_ml_model &lt;- &quot; functions{ real normal_lb_rng(real mu, real sigma, real lb) { real p = normal_cdf(lb | mu, sigma); // cdf for bounds real u = uniform_rng(p, 1); return (sigma * inv_Phi(u)) + mu; // inverse cdf for value } } // The input (data) for the model. data { int&lt;lower = 1&gt; trials; int&lt;lower = 1&gt; agents; array[trials, agents] int h; array[trials, agents] real win; array[trials, agents] real lose; } parameters { real winM; real loseM; vector&lt;lower = 0&gt;[2] tau; matrix[2, agents] z_IDs; cholesky_factor_corr[2] L_u; } transformed parameters { matrix[agents,2] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; } model { target += normal_lpdf(winM | 0, 1); target += normal_lpdf(tau[1] | 0, .3) - normal_lccdf(0 | 0, .3); target += normal_lpdf(loseM | 0, .3); target += normal_lpdf(tau[2] | 0, .3) - normal_lccdf(0 | 0, .3); target += lkj_corr_cholesky_lpdf(L_u | 2); target += std_normal_lpdf(to_vector(z_IDs)); for (i in 1:agents) target += bernoulli_logit_lpmf(h[,i] | to_vector(win[,i]) * (winM + IDs[i,1]) + to_vector(lose[,i]) * (loseM + IDs[i,2])); } generated quantities{ real winM_prior; real&lt;lower=0&gt; winSD_prior; real loseM_prior; real&lt;lower=0&gt; loseSD_prior; real win_prior; real lose_prior; array[trials,agents] int&lt;lower=0, upper = trials&gt; prior_preds; array[trials,agents] int&lt;lower=0, upper = trials&gt; posterior_preds; array[trials, agents] real log_lik; winM_prior = normal_rng(0,1); winSD_prior = normal_lb_rng(0,0.3,0); loseM_prior = normal_rng(0,1); loseSD_prior = normal_lb_rng(0,0.3,0); win_prior = normal_rng(winM_prior, winSD_prior); lose_prior = normal_rng(loseM_prior, loseSD_prior); for (i in 1:agents){ prior_preds[,i] = binomial_rng(trials, inv_logit(to_vector(win[,i]) * (win_prior) + to_vector(lose[,i]) * (lose_prior))); posterior_preds[,i] = binomial_rng(trials, inv_logit(to_vector(win[,i]) * (winM + IDs[i,1]) + to_vector(lose[,i]) * (loseM + IDs[i,2]))); for (t in 1:trials){ log_lik[t,i] = bernoulli_logit_lpmf(h[t,i] | to_vector(win[,i]) * (winM + IDs[i,1]) + to_vector(lose[,i]) * (loseM + IDs[i,2])); } } } &quot; write_stan_file( stan_wsls_ml_model, dir = &quot;stan/&quot;, basename = &quot;W8_wsls_ml.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W8_wsls_ml.stan&quot; file &lt;- file.path(&quot;stan/W8_wsls_ml.stan&quot;) mod_wsls &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;), pedantic = TRUE) ## Model executable is up to date! samples_wsls_ml &lt;- mod_wsls$sample( data = data_wsls, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 2000, refresh = 1000, max_treedepth = 20, adapt_delta = 0.99, ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 4000 [ 0%] (Warmup) ## Chain 2 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 2 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 2 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 1 Iteration: 1000 / 4000 [ 25%] (Warmup) ## Chain 1 Iteration: 2000 / 4000 [ 50%] (Warmup) ## Chain 1 Iteration: 2001 / 4000 [ 50%] (Sampling) ## Chain 2 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 1 Iteration: 3000 / 4000 [ 75%] (Sampling) ## Chain 2 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 2 finished in 152.1 seconds. ## Chain 1 Iteration: 4000 / 4000 [100%] (Sampling) ## Chain 1 finished in 152.4 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 152.3 seconds. ## Total execution time: 152.5 seconds. 8.10 Quality checks samples_wsls_ml$summary() ## # A tibble: 36,115 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -5918. -5918. 14.4 14.5 -5942. -5894. 1.00 935. 1890. ## 2 winM 1.45 1.45 0.0381 0.0370 1.39 1.51 1.00 3513. 2701. ## 3 loseM 1.56 1.56 0.0465 0.0453 1.48 1.64 1.00 4169. 3096. ## 4 tau[1] 0.219 0.219 0.0470 0.0462 0.142 0.296 1.00 1491. 1957. ## 5 tau[2] 0.267 0.268 0.0649 0.0629 0.158 0.370 1.00 1398. 1481. ## 6 z_IDs[1,1] -0.528 -0.540 0.773 0.755 -1.77 0.763 1.00 6725. 2580. ## 7 z_IDs[2,1] 0.206 0.196 0.834 0.858 -1.17 1.58 1.00 5901. 3209. ## 8 z_IDs[1,2] -0.393 -0.415 0.811 0.819 -1.72 0.936 1.00 6495. 3262. ## 9 z_IDs[2,2] -0.176 -0.162 0.838 0.800 -1.54 1.22 1.00 5623. 2673. ## 10 z_IDs[1,3] 0.662 0.672 0.800 0.801 -0.646 1.97 1.00 7498. 2768. ## # … with 36,105 more rows # Extract posterior samples and include sampling of the prior: draws_df &lt;- as_draws_df(samples_wsls_ml$draws()) # Now let&#39;s plot the density for theta (prior and posterior) ggplot(draws_df) + geom_density(aes(winM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(win_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d$betaWinM[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(`tau[1]`), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(`winSD_prior`), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d$betaWinSD[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(loseM), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(loseM_prior), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d$betaLoseM[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() ggplot(draws_df) + geom_density(aes(`tau[2]`), fill = &quot;blue&quot;, alpha = 0.3) + geom_density(aes(`loseSD_prior`), fill = &quot;red&quot;, alpha = 0.3) + geom_vline(xintercept = d$betaLoseSD[1]) + xlab(&quot;Rate&quot;) + ylab(&quot;Posterior Density&quot;) + theme_classic() [MISSING: Model comparison with biased] [MISSING: Mixture model with biased] "],["bayesian-models-of-cognition.html", "Chapter 9 Bayesian models of cognition 9.1 Load the packages 9.2 Design the model 9.3 Create the data 9.4 Visualize 9.5 Data for Stan 9.6 Create the Stan Model 9.7 Fitting the model 9.8 Basic evaluation 9.9 Weighted Bayes 9.10 Visualize 9.11 Build the Weighted Bayes Stan model (simple formula) 9.12 Model evaluation 9.13 Model recovery 9.14 Bonus: Build the Weighted Bayes Stan model (fancier formula) 9.15 Evaluation 9.16 Bonus: Build a temporal Bayes (storing current belief as prior for next turn) 9.17 Evaluate 9.18 Multilevel version of the simple bayes model 9.19 Multilevel version of the weighted bayes model", " Chapter 9 Bayesian models of cognition 9.1 Load the packages pacman::p_load( tidyverse, brms, cmdstanr, patchwork ) 9.2 Design the model [MISSING: EXPLAIN THE MODEL] [MISSING: Explain the different outcomes, including examples of experiments] SimpleBayes_f &lt;- function(bias, Source1, Source2){ outcome &lt;- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2)) return(outcome) } SimpleBayes_MultiSource_f &lt;- function(bias, sources) { outcome &lt;- inv_logit_scaled(bias + sum(logit_scaled(sources))) return(outcome) } 9.3 Create the data bias &lt;- 0 trials &lt;- seq(10) Source1 &lt;- seq(0.1,0.9, 0.1) Source2 &lt;- seq(0.1,0.9, 0.1) db &lt;- expand.grid(bias = bias, trials = trials, Source1 = Source1, Source2 = Source2) for (n in seq(nrow(db))) { db$belief[n] &lt;- SimpleBayes_f(db$bias[n], db$Source1[n], db$Source2[n]) db$choice[n] &lt;- rbinom(1,1, db$belief[n]) db$continuous[n] &lt;- db$belief[n]*9 db$discrete[n] &lt;- round(db$belief[n]*9,0) } 9.4 Visualize [MISSING: Explain] ggplot(db, aes(belief)) + geom_histogram(bins = 10, alpha = 0.3, color = &quot;black&quot;) + theme_bw() ggplot(db, aes(Source1, belief, color = Source2, group = Source2)) + geom_line() + theme_bw() ggplot(db, aes(choice)) + geom_histogram(bins = 10, alpha = 0.3, color = &quot;black&quot;) + theme_bw() ggplot(db, aes(Source1, choice, color = Source2, group = Source2)) + geom_smooth(se = F) + theme_bw() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot(db, aes(continuous)) + geom_histogram(bins = 10, alpha = 0.3, color = &quot;black&quot;) + theme_bw() ggplot(db, aes(Source1, continuous, color = Source2, group = Source2)) + geom_smooth() + theme_bw() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; ggplot(db, aes(discrete)) + geom_histogram(bins = 10, alpha = 0.3, color = &quot;black&quot;) + theme_bw() ggplot(db, aes(Source1, discrete, color = Source2, group = Source2)) + geom_smooth() + theme_bw() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; 9.5 Data for Stan data_simpleBayes &lt;- list( N = nrow(db), y = db$choice, Source1 = db$Source1, Source2 = db$Source2 ) 9.6 Create the Stan Model stan_simpleBayes_model &lt;- &quot; data { int&lt;lower=0&gt; N; array[N] int y; array[N] real&lt;lower=0, upper = 1&gt; Source1; array[N] real&lt;lower=0, upper = 1&gt; Source2; } transformed data{ array[N] real l_Source1; array[N] real l_Source2; l_Source1 = logit(Source1); l_Source2 = logit(Source2); } parameters { real bias; } model { target += normal_lpdf(bias | 0, 1); target += bernoulli_logit_lpmf(y | bias + to_vector(l_Source1) + to_vector(l_Source2)); } generated quantities{ real bias_prior; array[N] real log_lik; bias_prior = normal_rng(0, 1); for (n in 1:N){ log_lik[n] = bernoulli_logit_lpmf(y[n] | bias + l_Source1[n] + l_Source2[n]); } } &quot; write_stan_file( stan_simpleBayes_model, dir = &quot;stan/&quot;, basename = &quot;W9_SimpleBayes.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_SimpleBayes.stan&quot; file &lt;- file.path(&quot;stan/W9_SimpleBayes.stan&quot;) mod_simpleBayes &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 9.7 Fitting the model samples_simple &lt;- mod_simpleBayes$sample( data = data_simpleBayes, #fixed_param = TRUE, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 1.0 seconds. ## Chain 2 finished in 1.0 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 1.0 seconds. ## Total execution time: 1.1 seconds. 9.8 Basic evaluation samples_simple$cmdstan_diagnose() ## Processing csv files: /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_SimpleBayes-202303240944-1-6e917d.csv, /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_SimpleBayes-202303240944-2-6e917d.csv ## ## Checking sampler transitions treedepth. ## Treedepth satisfactory for all transitions. ## ## Checking sampler transitions for divergences. ## No divergent transitions found. ## ## Checking E-BFMI - sampler transitions HMC potential energy. ## E-BFMI satisfactory. ## ## Effective sample size satisfactory. ## ## Split R-hat values satisfactory all parameters. ## ## Processing complete, no problems detected. samples_simple$summary() ## # A tibble: 813 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -370. -370. 0.709 0.316 -372. -370. 1.00 3441. 3774. ## 2 bias -0.0787 -0.0791 0.0893 0.0892 -0.224 0.0700 1.00 2183. 2913. ## 3 bias_prior -0.00555 -0.0113 0.995 0.996 -1.63 1.62 1.00 5885. 5601. ## 4 log_lik[1] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 5 log_lik[2] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 6 log_lik[3] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 7 log_lik[4] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 8 log_lik[5] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 9 log_lik[6] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## 10 log_lik[7] -0.0114 -0.0113 0.00101 0.00100 -0.0132 -0.00982 1.00 2183. 2913. ## # … with 803 more rows samples_simple$loo() ## ## Computed from 6000 by 810 log-likelihood matrix ## ## Estimate SE ## elpd_loo -369.6 14.3 ## p_loo 1.0 0.0 ## looic 739.3 28.6 ## ------ ## Monte Carlo SE of elpd_loo is 0.0. ## ## All Pareto k estimates are good (k &lt; 0.5). ## See help(&#39;pareto-k-diagnostic&#39;) for details. draws_df &lt;- as_draws_df(samples_simple$draws()) ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df) + geom_density(aes(bias), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(bias_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db$bias[1]) + theme_bw() [MISSING PARAMETER RECOVERY] 9.9 Weighted Bayes [MISSING: EXPLANATION] [MISSING: FOCUS ON WEIGHTS AND THEIR SCALE: 0-1 on log-odds; 0.5-1 on probability] WeightedBayes_f &lt;- function(bias, Source1, Source2, w1, w2){ w1 &lt;- (w1 - 0.5)*2 w2 &lt;- (w2 - 0.5)*2 outcome &lt;- inv_logit_scaled(bias + w1 * logit_scaled(Source1) + w2 * logit_scaled(Source2)) return(outcome) } ## This version of the model is from Taking others into account (in the syllabus) ## It takes two sources of information and weights them, then adds a bias ## to generate a posterior on a 0-1 scale WeightedBayes_f1 &lt;- function(bias, Source1, Source2, w1, w2){ outcome &lt;- inv_logit_scaled(bias + weight_f(logit_scaled(Source1), w1) + weight_f(logit_scaled(Source2), w2)) return(outcome) } ## The weight_f formula comes from https://www.nature.com/articles/ncomms14218 ## and ensures that even if we work on a log-odds scale, we get the right weights ## It takes all values of L (- inf to +inf). Technically the only valid values for ## w are 0.5 (no consideration of the evidence) to 1 (taking the evidence at face value). ## In practice the function would also accept 0-0.5 (invert the evidence, at face value ## if 0, at decreased value as it grows towards 0.5), and slightly higher than 1 ## (overweighing the evidence, but it&#39;s very unstable and quickly gives NaN). weight_f &lt;- function(L, w){ return(log((w * exp(L) + 1 - w) / ((1 - w) * exp(L) + w))) } bias &lt;- 0 trials &lt;- seq(10) Source1 &lt;- seq(0.1,0.9, 0.1) Source2 &lt;- seq(0.1,0.9, 0.1) w1 &lt;- seq(0.5, 1, 0.1) w2 &lt;- seq(0.5, 1, 0.1) db &lt;- expand.grid(bias = bias, trials, Source1 = Source1, Source2 = Source2, w1 = w1, w2 = w2) for (n in seq(nrow(db))) { db$belief[n] &lt;- WeightedBayes_f(db$bias[n], db$Source1[n], db$Source2[n],db$w1[n], db$w2[n]) db$belief1[n] &lt;- WeightedBayes_f1(db$bias[n], db$Source1[n], db$Source2[n],db$w1[n], db$w2[n]) db$binary[n] &lt;- rbinom(1,1, db$belief[n]) db$binary1[n] &lt;- rbinom(1,1, db$belief1[n]) db$continuous[n] &lt;- db$belief[n] * 9 db$continuous1[n] &lt;- db$belief1[n] * 9 db$discrete[n] &lt;- round(db$belief[n] * 9,0) db$discrete1[n] &lt;- round(db$belief1[n] * 9,0) } 9.10 Visualize ggplot(db, aes(belief, belief1)) + geom_point() + theme_bw() ggplot(db) + geom_histogram(aes(belief), bins = 10, alpha = 0.3, color = &quot;black&quot;, fill = &quot;red&quot;) + geom_histogram(aes(belief1), bins = 10, alpha = 0.3, color = &quot;black&quot;, fill = &quot;blue&quot;) + theme_bw() p1 &lt;- ggplot(db, aes(Source1, belief, color = Source2, group = Source2)) + geom_line() + theme_bw() + facet_wrap(w1~w2) p2 &lt;- ggplot(db, aes(Source1, belief1, color = Source2, group = Source2)) + geom_line() + theme_bw() + facet_wrap(w1~w2) p1 + p2 9.11 Build the Weighted Bayes Stan model (simple formula) stan_WB_model &lt;- &quot; data { int&lt;lower=0&gt; N; array[N] int y; array[N] real &lt;lower = 0, upper = 1&gt; Source1; array[N] real &lt;lower = 0, upper = 1&gt; Source2; } transformed data { array[N] real l_Source1; array[N] real l_Source2; l_Source1 = logit(Source1); l_Source2 = logit(Source2); } parameters { real bias; // meaningful weights are btw 0.5 and 1 (theory reasons) real&lt;lower = 0.5, upper = 1&gt; w1; real&lt;lower = 0.5, upper = 1&gt; w2; } transformed parameters { real&lt;lower = 0, upper = 1&gt; weight1; real&lt;lower = 0, upper = 1&gt; weight2; // weight parameters are rescaled to be on a 0-1 scale (0 -&gt; no effects; 1 -&gt; face value) weight1 = (w1 - 0.5) * 2; weight2 = (w2 - 0.5) * 2; } model { target += normal_lpdf(bias | 0, 1); target += beta_lpdf(weight1 | 1, 1); target += beta_lpdf(weight2 | 1, 1); for (n in 1:N) target += bernoulli_logit_lpmf(y[n] | bias + weight1 *l_Source1[n] + weight2 * l_Source2[n]); } generated quantities{ array[N] real log_lik; real bias_prior; real w1_prior; real w2_prior; bias_prior = normal_rng(0, 1) ; w1_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; w2_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; for (n in 1:N) log_lik[n]= bernoulli_logit_lpmf(y[n] | bias + weight1 * l_Source1[n] + weight2 * l_Source2[n]); } &quot; write_stan_file( stan_WB_model, dir = &quot;stan/&quot;, basename = &quot;W9_WB.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_WB.stan&quot; file &lt;- file.path(&quot;stan/W9_WB.stan&quot;) mod_wb &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! db1 &lt;- db %&gt;% subset(w1 == 0.7 &amp; w2 == 0.9) p3 &lt;- ggplot(db1, aes(Source1, belief, color = Source2, group = Source2)) + geom_line() + theme_bw() p3 ggplot(db1, aes(Source1, binary)) + geom_smooth() + theme_bw() ## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; data_weightedBayes &lt;- list( N = nrow(db1), y = db1$binary, Source1 = db1$Source1, Source2 = db1$Source2 ) samples_weighted &lt;- mod_wb$sample( data = data_weightedBayes, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 finished in 3.8 seconds. ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 3.8 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 3.8 seconds. ## Total execution time: 3.9 seconds. 9.12 Model evaluation samples_weighted$cmdstan_diagnose() ## Processing csv files: /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_WB-202303240944-1-0c3d84.csv, /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_WB-202303240944-2-0c3d84.csv ## ## Checking sampler transitions treedepth. ## Treedepth satisfactory for all transitions. ## ## Checking sampler transitions for divergences. ## No divergent transitions found. ## ## Checking E-BFMI - sampler transitions HMC potential energy. ## E-BFMI satisfactory. ## ## Effective sample size satisfactory. ## ## Split R-hat values satisfactory all parameters. ## ## Processing complete, no problems detected. samples_weighted$summary() ## # A tibble: 819 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -470. -470. 1.29 1.06 -473. -469. 1.00 2393. 3666. ## 2 bias -0.00470 -0.00431 0.0791 0.0808 -0.132 0.125 1.00 4579. 4261. ## 3 w1 0.724 0.724 0.0319 0.0324 0.672 0.777 1.00 5058. 3642. ## 4 w2 0.887 0.887 0.0350 0.0353 0.831 0.947 1.00 4355. 2472. ## 5 weight1 0.448 0.447 0.0639 0.0649 0.343 0.554 1.00 5058. 3642. ## 6 weight2 0.775 0.774 0.0701 0.0706 0.661 0.893 1.00 4355. 2472. ## 7 log_lik[1] -0.0673 -0.0660 0.0159 0.0160 -0.0958 -0.0439 1.00 4269. 3298. ## 8 log_lik[2] -0.0673 -0.0660 0.0159 0.0160 -0.0958 -0.0439 1.00 4269. 3298. ## 9 log_lik[3] -2.76 -2.75 0.228 0.235 -3.15 -2.39 1.00 4269. 3298. ## 10 log_lik[4] -0.0673 -0.0660 0.0159 0.0160 -0.0958 -0.0439 1.00 4269. 3298. ## # … with 809 more rows samples_weighted$loo() ## ## Computed from 6000 by 810 log-likelihood matrix ## ## Estimate SE ## elpd_loo -466.4 12.7 ## p_loo 3.0 0.2 ## looic 932.8 25.4 ## ------ ## Monte Carlo SE of elpd_loo is 0.0. ## ## All Pareto k estimates are good (k &lt; 0.5). ## See help(&#39;pareto-k-diagnostic&#39;) for details. draws_df &lt;- as_draws_df(samples_weighted$draws()) ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df, aes(.iteration, w1, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df, aes(.iteration, w2, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() p1 &lt;- ggplot(draws_df) + geom_density(aes(bias), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(bias_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$bias[1]) + theme_bw() p2 &lt;- ggplot(draws_df) + geom_density(aes(w1), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(w1_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w1[1]) + theme_bw() p3 &lt;- ggplot(draws_df) + geom_density(aes(w2), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(w2_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w2[1]) + theme_bw() p1 + p2 + p3 ggplot(draws_df) + geom_point(aes(w1, w2), alpha = 0.3) + theme_bw() ggplot(draws_df) + geom_point(aes(bias, w1), alpha = 0.3) + theme_bw() ggplot(draws_df) + geom_point(aes(bias, w2), alpha = 0.3) + theme_bw() 9.13 Model recovery bias &lt;- 0 trials &lt;- seq(10) Source1 &lt;- seq(0.1,0.9, 0.1) Source2 &lt;- seq(0.1,0.9, 0.1) w1 &lt;- 0.7 w2 &lt;- 0.9 db &lt;- expand.grid(bias = bias, trials, Source1 = Source1, Source2 = Source2, w1 = w1, w2 = w2) for (n in seq(nrow(db))) { db$simple_belief[n] &lt;- SimpleBayes_f(db$bias[n], db$Source1[n], db$Source2[n]) db$weighted_belief[n] &lt;- WeightedBayes_f(db$bias[n], db$Source1[n], db$Source2[n],db$w1[n], db$w2[n]) db$simple_binary[n] &lt;- rbinom(1,1, db$simple_belief[n]) db$weighted_binary[n] &lt;- rbinom(1,1, db$weighted_belief[n]) } data_SB &lt;- list( N = nrow(db), y = db$simple_binary, Source1 = db$Source1, Source2 = db$Source2 ) data_WB &lt;- list( N = nrow(db), y = db$weighted_binary, Source1 = db$Source1, Source2 = db$Source2 ) ## On the simple data simple2simple &lt;- mod_simpleBayes$sample( data = data_SB, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 1.1 seconds. ## Chain 2 finished in 1.1 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 1.1 seconds. ## Total execution time: 1.2 seconds. weighted2simple &lt;- mod_wb$sample( data = data_SB, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 4.3 seconds. ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 finished in 4.6 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 4.4 seconds. ## Total execution time: 4.6 seconds. simple2weighted &lt;- mod_simpleBayes$sample( data = data_WB, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 1.1 seconds. ## Chain 2 finished in 1.0 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 1.1 seconds. ## Total execution time: 1.2 seconds. weighted2weighted &lt;- mod_wb$sample( data = data_WB, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 3.6 seconds. ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 finished in 3.8 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 3.7 seconds. ## Total execution time: 4.0 seconds. Loo_simple2simple &lt;- simple2simple$loo(save_psis = TRUE, cores = 4) p1 &lt;- plot(Loo_simple2simple) Loo_weighted2simple &lt;- weighted2simple$loo(save_psis = TRUE, cores = 4) p2 &lt;- plot(Loo_weighted2simple) Loo_simple2weighted &lt;- simple2weighted$loo(save_psis = TRUE, cores = 4) p3 &lt;- plot(Loo_simple2weighted) Loo_weighted2weighted &lt;- weighted2weighted$loo(save_psis = TRUE, cores = 4) p4 &lt;- plot(Loo_weighted2weighted) elpd &lt;- tibble( n = seq(810), simple_diff_elpd = Loo_simple2simple$pointwise[, &quot;elpd_loo&quot;] - Loo_weighted2simple$pointwise[, &quot;elpd_loo&quot;], weighted_diff_elpd = Loo_weighted2weighted$pointwise[, &quot;elpd_loo&quot;] - Loo_simple2weighted$pointwise[, &quot;elpd_loo&quot;]) p1 &lt;- ggplot(elpd, aes(x = n, y = simple_diff_elpd)) + geom_point(alpha = .1) + #xlim(.5,1.01) + #ylim(-1.5,1.5) + geom_hline(yintercept = 0, color = &quot;red&quot;, linetype = &quot;dashed&quot;) + theme_bw() p2 &lt;- ggplot(elpd, aes(x = n, y = weighted_diff_elpd)) + geom_point(alpha = .1) + #xlim(.5,1.01) + #ylim(-1.5,1.5) + geom_hline(yintercept = 0, color = &quot;red&quot;, linetype = &quot;dashed&quot;) + theme_bw() library(patchwork) p1 + p2 loo_compare(Loo_simple2simple, Loo_weighted2simple) ## elpd_diff se_diff ## model1 0.0 0.0 ## model2 -1.2 1.1 loo_compare(Loo_weighted2weighted, Loo_simple2weighted) ## elpd_diff se_diff ## model1 0.0 0.0 ## model2 -53.0 11.7 loo_model_weights(list(Loo_simple2simple, Loo_weighted2simple)) ## Method: stacking ## ------ ## weight ## model1 1.000 ## model2 0.000 loo_model_weights(list(Loo_weighted2weighted, Loo_simple2weighted)) ## Method: stacking ## ------ ## weight ## model1 0.969 ## model2 0.031 9.14 Bonus: Build the Weighted Bayes Stan model (fancier formula) stan_WB1_model &lt;- &quot; functions{ real weight_f(real L_raw, real w_raw) { real L; real w; L = exp(L_raw); w = 0.5 + inv_logit(w_raw)/2; return log((w * L + 1 - w)./((1 - w) * L + w)); } } data { int&lt;lower=0&gt; N; array[N] int y; vector[N] Source1; vector[N] Source2; } parameters { real bias; real weight1; real weight2; } model { target += normal_lpdf(bias | 0, 1); target += normal_lpdf(weight1 | 0, 1.5); target += normal_lpdf(weight2 | 0, 1.5); for (n in 1:N){ target += bernoulli_logit_lpmf(y[n] | bias + weight_f(Source1[n], weight1) + weight_f(Source2[n], weight2)); } } generated quantities{ array[N] real log_lik; real bias_prior; real w1_prior; real w2_prior; real w1; real w2; bias_prior = normal_rng(0,1); w1_prior = normal_rng(0,1.5); w2_prior = normal_rng(0,1.5); w1_prior = 0.5 + inv_logit(normal_rng(0,1))/2; w2_prior = 0.5 + inv_logit(normal_rng(0,1))/2; w1 = 0.5 + inv_logit(weight1)/2; w2 = 0.5 + inv_logit(weight2)/2; for (n in 1:N){ log_lik[n] = bernoulli_logit_lpmf(y[n] | bias + weight_f(Source1[n], weight1) + weight_f(Source2[n], weight2)); } } &quot; write_stan_file( stan_WB1_model, dir = &quot;stan/&quot;, basename = &quot;W9_WB1.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_WB1.stan&quot; file &lt;- file.path(&quot;stan/W9_WB1.stan&quot;) mod_wb1 &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! db1 &lt;- db %&gt;% subset(w1 == 0.7 &amp; w2 == 1) %&gt;% mutate( l1 = logit_scaled(Source1), l2 = logit_scaled(Source2) ) data_weightedBayes1 &lt;- list( N = nrow(db1), y = db1$binary1, Source1 = logit_scaled(db1$Source1), Source2 = logit_scaled(db1$Source2) ) samples_weighted1 &lt;- mod_wb1$sample( data = data_weightedBayes1, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 1500, iter_sampling = 3000, refresh = 500 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 1 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 1 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 1 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 1 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 1 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 1 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 1 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 1 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 1 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 2 Iteration: 1 / 4500 [ 0%] (Warmup) ## Chain 2 Iteration: 500 / 4500 [ 11%] (Warmup) ## Chain 2 Iteration: 1000 / 4500 [ 22%] (Warmup) ## Chain 2 Iteration: 1500 / 4500 [ 33%] (Warmup) ## Chain 2 Iteration: 1501 / 4500 [ 33%] (Sampling) ## Chain 2 Iteration: 2000 / 4500 [ 44%] (Sampling) ## Chain 2 Iteration: 2500 / 4500 [ 55%] (Sampling) ## Chain 2 Iteration: 3000 / 4500 [ 66%] (Sampling) ## Chain 2 Iteration: 3500 / 4500 [ 77%] (Sampling) ## Chain 2 Iteration: 4000 / 4500 [ 88%] (Sampling) ## Chain 2 Iteration: 4500 / 4500 [100%] (Sampling) ## Chain 1 finished in 0.0 seconds. ## Chain 2 finished in 0.0 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 0.0 seconds. ## Total execution time: 0.1 seconds. 9.15 Evaluation draws_df &lt;- as_draws_df(samples_weighted1$draws()) ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df, aes(.iteration, w1, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df, aes(.iteration, w2, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() ggplot(draws_df) + geom_histogram(aes(bias), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_histogram(aes(bias_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$bias[1]) + theme_bw() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1 rows containing missing values (`geom_vline()`). ggplot(draws_df) + geom_histogram(aes(w1), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_histogram(aes(w1_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w1[1]) + theme_bw() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1 rows containing missing values (`geom_vline()`). ggplot(draws_df) + geom_density(aes(w2), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(w2_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w2[1]) + theme_bw() ## Warning: Removed 1 rows containing missing values (`geom_vline()`). ggplot(draws_df) + geom_point(aes(w1, w2), alpha = 0.3) + theme_bw() ggplot(draws_df) + geom_point(aes(bias, w1), alpha = 0.3) + theme_bw() ggplot(draws_df) + geom_point(aes(bias, w2), alpha = 0.3) + theme_bw() 9.16 Bonus: Build a temporal Bayes (storing current belief as prior for next turn) WeightedTimeBayes_f &lt;- function(bias, Source1, Source2, w1, w2){ w1 &lt;- (w1 - 0.5)*2 w2 &lt;- (w2 - 0.5)*2 outcome &lt;- inv_logit_scaled(bias + w1 * logit_scaled(Source1) + w2 * logit_scaled(Source2)) return(outcome) } bias &lt;- 0 trials &lt;- seq(10) Source1 &lt;- seq(0.1,0.9, 0.1) w1 &lt;- seq(0.5, 1, 0.1) w2 &lt;- seq(0.5, 1, 0.1) db &lt;- expand.grid(bias = bias, trials, Source1 = Source1, w1 = w1, w2 = w2) %&gt;% mutate(Source2 = NA, belief = NA, binary = NA) for (n in seq(nrow(db))) { if (n == 1) {db$Source2[1] = 0.5} db$belief[n] &lt;- WeightedTimeBayes_f(db$bias[n], db$Source1[n], db$Source2[n],db$w1[n], db$w2[n]) db$binary[n] &lt;- rbinom(1,1, db$belief[n]) if (n &lt; nrow(db)) {db$Source2[n + 1] &lt;- db$belief[n]} } stan_TB_model &lt;- &quot; data { int&lt;lower=0&gt; N; array[N] int y; array[N] real &lt;lower = 0, upper = 1&gt; Source1; } transformed data { array[N] real l_Source1; l_Source1 = logit(Source1); } parameters { real bias; // meaningful weights are btw 0.5 and 1 (theory reasons) real&lt;lower = 0.5, upper = 1&gt; w1; real&lt;lower = 0.5, upper = 1&gt; w2; } transformed parameters { real&lt;lower = 0, upper = 1&gt; weight1; real&lt;lower = 0, upper = 1&gt; weight2; array[N] real l_Source2; // weight parameters are rescaled to be on a 0-1 scale (0 -&gt; no effects; 1 -&gt; face value) weight1 = (w1 - 0.5) * 2; weight2 = (w2 - 0.5) * 2; l_Source2[1] = 0; for (n in 2:N){ l_Source2[n] = bias + weight1 * l_Source1[n] + weight2 * l_Source2[n-1]; } } model { target += normal_lpdf(bias | 0, 1); target += beta_lpdf(weight1 | 1, 1); target += beta_lpdf(weight2 | 1, 1); target += bernoulli_logit_lpmf(y[1] | bias + weight1 * l_Source1[1]); for (n in 2:N){ target += bernoulli_logit_lpmf(y[n] | l_Source2[n]); } } generated quantities{ array[N] real log_lik; real bias_prior; real w1_prior; real w2_prior; bias_prior = normal_rng(0, 1) ; w1_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; w2_prior = 0.5 + inv_logit(normal_rng(0, 1))/2 ; for (n in 1:N) log_lik[n]= bernoulli_logit_lpmf(y[n] | l_Source2[n]); } &quot; write_stan_file( stan_TB_model, dir = &quot;stan/&quot;, basename = &quot;W9_TB.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_TB.stan&quot; file &lt;- file.path(&quot;stan/W9_TB.stan&quot;) mod_tb &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! db1 &lt;- db %&gt;% subset(w1 == 0.7 &amp; w2 == 0.9) data_TB &lt;- list( N = nrow(db1), y = db1$binary, Source1 = db1$Source1 ) samples_TB &lt;- mod_tb$sample( data = data_TB, seed = 123, chains = 2, parallel_chains = 2, threads_per_chain = 2, iter_warmup = 2000, iter_sampling = 3000, refresh = 500, adapt_delta = 0.99, max_treedepth = 20 ) ## Running MCMC with 2 parallel chains, with 2 thread(s) per chain... ## ## Chain 1 Iteration: 1 / 5000 [ 0%] (Warmup) ## Chain 2 Iteration: 1 / 5000 [ 0%] (Warmup) ## Chain 1 Iteration: 500 / 5000 [ 10%] (Warmup) ## Chain 2 Iteration: 500 / 5000 [ 10%] (Warmup) ## Chain 1 Iteration: 1000 / 5000 [ 20%] (Warmup) ## Chain 2 Iteration: 1000 / 5000 [ 20%] (Warmup) ## Chain 1 Iteration: 1500 / 5000 [ 30%] (Warmup) ## Chain 2 Iteration: 1500 / 5000 [ 30%] (Warmup) ## Chain 1 Iteration: 2000 / 5000 [ 40%] (Warmup) ## Chain 1 Iteration: 2001 / 5000 [ 40%] (Sampling) ## Chain 2 Iteration: 2000 / 5000 [ 40%] (Warmup) ## Chain 2 Iteration: 2001 / 5000 [ 40%] (Sampling) ## Chain 1 Iteration: 2500 / 5000 [ 50%] (Sampling) ## Chain 2 Iteration: 2500 / 5000 [ 50%] (Sampling) ## Chain 1 Iteration: 3000 / 5000 [ 60%] (Sampling) ## Chain 2 Iteration: 3000 / 5000 [ 60%] (Sampling) ## Chain 2 Iteration: 3500 / 5000 [ 70%] (Sampling) ## Chain 1 Iteration: 3500 / 5000 [ 70%] (Sampling) ## Chain 1 Iteration: 4000 / 5000 [ 80%] (Sampling) ## Chain 2 Iteration: 4000 / 5000 [ 80%] (Sampling) ## Chain 2 Iteration: 4500 / 5000 [ 90%] (Sampling) ## Chain 1 Iteration: 4500 / 5000 [ 90%] (Sampling) ## Chain 2 Iteration: 5000 / 5000 [100%] (Sampling) ## Chain 2 finished in 1.4 seconds. ## Chain 1 Iteration: 5000 / 5000 [100%] (Sampling) ## Chain 1 finished in 1.6 seconds. ## ## Both chains finished successfully. ## Mean chain execution time: 1.5 seconds. ## Total execution time: 1.7 seconds. 9.17 Evaluate samples_TB$cmdstan_diagnose() ## Processing csv files: /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_TB-202303240945-1-712387.csv, /var/folders/lt/zspkqnxd5yg92kybm5f433_cfjr0d6/T/Rtmp1QPjNY/W9_TB-202303240945-2-712387.csv ## ## Checking sampler transitions treedepth. ## Treedepth satisfactory for all transitions. ## ## Checking sampler transitions for divergences. ## No divergent transitions found. ## ## Checking E-BFMI - sampler transitions HMC potential energy. ## E-BFMI satisfactory. ## ## Effective sample size satisfactory. ## ## Split R-hat values satisfactory all parameters. ## ## Processing complete, no problems detected. #samples_TB$loo() samples_TB$summary() ## # A tibble: 189 × 10 ## variable mean median sd mad q5 q95 rhat ess_bulk ess_tail ## &lt;chr&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1 lp__ -48.4 -47.9 1.70 1.46 -51.8 -46.5 1.00 983. 1460. ## 2 bias -0.0850 -0.0673 0.136 0.116 -0.336 0.105 1.00 1793. 1710. ## 3 w1 0.815 0.817 0.104 0.122 0.643 0.978 1.00 944. 1460. ## 4 w2 0.777 0.788 0.0937 0.0972 0.602 0.909 1.00 880. 1331. ## 5 weight1 0.630 0.633 0.207 0.244 0.286 0.955 1.00 944. 1460. ## 6 weight2 0.555 0.576 0.187 0.194 0.205 0.818 1.00 880. 1331. ## 7 l_Source2[1] 0 0 0 0 0 0 NA NA NA ## 8 l_Source2[2] -1.47 -1.47 0.514 0.597 -2.29 -0.640 1.00 943. 1463. ## 9 l_Source2[3] -2.21 -2.24 0.620 0.668 -3.20 -1.14 1.00 1175. 1522. ## 10 l_Source2[4] -2.63 -2.64 0.655 0.671 -3.68 -1.52 1.00 1530. 1731. ## # … with 179 more rows draws_df &lt;- as_draws_df(samples_TB$draws()) p1 &lt;- ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() p2 &lt;- ggplot(draws_df, aes(.iteration, w1, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() p3 &lt;- ggplot(draws_df, aes(.iteration, w2, group = .chain, color = .chain)) + geom_line(alpha = 0.5) + theme_classic() p1 + p2 + p3 p1 &lt;- ggplot(draws_df) + geom_density(aes(bias), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(bias_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$bias[1]) + theme_bw() p2 &lt;- ggplot(draws_df) + geom_density(aes(w1), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(w1_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w1[1]) + theme_bw() p3 &lt;- ggplot(draws_df) + geom_density(aes(w2), alpha = 0.6, fill = &quot;lightblue&quot;) + geom_density(aes(w2_prior), alpha = 0.6, fill = &quot;pink&quot;) + geom_vline(xintercept = db1$w2[1]) + theme_bw() p1 + p2 + p3 p1 &lt;- ggplot(draws_df) + geom_point(aes(w1, w2), alpha = 0.3) + theme_bw() p2 &lt;- ggplot(draws_df) + geom_point(aes(bias, w1), alpha = 0.3) + theme_bw() p3 &lt;- ggplot(draws_df) + geom_point(aes(bias, w2), alpha = 0.3) + theme_bw() p1 + p2 + p3 [MISSING: model seems good at recovering. BUT HIGH correlations between weights and funnels, so we would probably be safer reparameterizing] 9.18 Multilevel version of the simple bayes model stan_simpleBayes_ml_model &lt;- &quot; data { int&lt;lower=0&gt; N; // n of trials int&lt;lower=0&gt; S; // n of participants array[N, S] int y; array[N, S] real&lt;lower=0, upper = 1&gt; Source1; array[N, S] real&lt;lower=0, upper = 1&gt; Source2; } transformed data{ array[N, S] real l_Source1; array[N, S] real l_Source2; l_Source1 = logit(Source1); l_Source2 = logit(Source2); } parameters { real biasM; real biasSD; array[S] real z_bias; } transformed parameters { vector[S] biasC; vector[S] bias; biasC = biasSD * to_vector(z_bias); bias = biasM + biasC; } model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(biasSD | 0, 1) - normal_lccdf(0 | 0, 1); target += std_normal_lpdf(to_vector(z_bias)); for (s in 1:S){ target += bernoulli_logit_lpmf(y[,s] | bias[s] + to_vector(l_Source1[,s]) + to_vector(l_Source2[,s])); } } &quot; write_stan_file( stan_simpleBayes_ml_model, dir = &quot;stan/&quot;, basename = &quot;W9_SimpleBayes_ml.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_SimpleBayes_ml.stan&quot; file &lt;- file.path(&quot;stan/W9_SimpleBayes_ml.stan&quot;) mod_simpleBayes &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! 9.19 Multilevel version of the weighted bayes model stan_WB_ml_model &lt;- &quot; data { int&lt;lower=0&gt; N; // n of trials int&lt;lower=0&gt; S; // n of participants array[N, S] int y; array[N, S] real&lt;lower=0, upper = 1&gt; Source1; array[N, S] real&lt;lower=0, upper = 1&gt; Source2; } transformed data { array[N,S] real l_Source1; array[N,S] real l_Source2; l_Source1 = logit(Source1); l_Source2 = logit(Source2); } parameters { real biasM; real w1_M; real w2_M; vector&lt;lower = 0&gt;[3] tau; matrix[3, S] z_IDs; cholesky_factor_corr[3] L_u; } transformed parameters{ matrix[S,3] IDs; IDs = (diag_pre_multiply(tau, L_u) * z_IDs)&#39;; } model { target += normal_lpdf(biasM | 0, 1); target += normal_lpdf(tau[1] | 0, 1) - normal_lccdf(0 | 0, 1); target += normal_lpdf(w1_M | 0, 1); target += normal_lpdf(tau[2] | 0, 1) - normal_lccdf(0 | 0, 1); target += normal_lpdf(w2_M | 0, 1); target += normal_lpdf(tau[3] | 0, 1) - normal_lccdf(0 | 0, 1); target += lkj_corr_cholesky_lpdf(L_u | 3); target += std_normal_lpdf(to_vector(z_IDs)); for (s in 1:S){ for (n in 1:N){ target += bernoulli_logit_lpmf(y[n,s] | biasM + IDs[s, 1] + (w1_M + IDs[s, 2]) * l_Source1[n,s] + (w2_M + IDs[s, 3]) * l_Source2[n,s]); }} } &quot; write_stan_file( stan_WB_ml_model, dir = &quot;stan/&quot;, basename = &quot;W9_WB_ml.stan&quot;) ## [1] &quot;/Users/au209589/Dropbox/Teaching/AdvancedCognitiveModeling23_book/stan/W9_WB_ml.stan&quot; file &lt;- file.path(&quot;stan/W9_WB_ml.stan&quot;) mod_wb &lt;- cmdstan_model(file, cpp_options = list(stan_threads = TRUE), stanc_options = list(&quot;O1&quot;)) ## Model executable is up to date! [MISSING: Fitting on real data and model comparison] "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
